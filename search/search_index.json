{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GraalVM Native Image","text":""},{"location":"#collect-metadata-with-the-tracing-agent","title":"Collect Metadata with the Tracing Agent","text":"<p>The Native Image tool relies on the static analysis of an application's reachable code at runtime.  However, the analysis cannot always completely predict all usages of the Java Native Interface (JNI), Java Reflection, Dynamic Proxy objects, or class path resources.  Undetected usages of these dynamic features must be provided to the <code>native-image</code> tool in the form of metadata (precomputed in code or as JSON configuration files).</p> <p>Here you will find information how to automatically collect metadata for an application and write JSON configuration files. To learn how to compute dynamic feature calls in code, see Reachability Metadata.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Tracing Agent</li> <li>Conditional Metadata Collection</li> <li>Agent Advanced Usage</li> <li>Native Image Configure Tool</li> </ul>"},{"location":"#tracing-agent","title":"Tracing Agent","text":"<p>GraalVM provides a Tracing Agent to easily gather metadata and prepare configuration files.  The agent tracks all usages of dynamic features during application execution on a regular Java VM.</p> <p>Enable the agent on the command line with the <code>java</code> command from the GraalVM JDK:</p> <pre><code>$JAVA_HOME/bin/java -agentlib:native-image-agent=config-output-dir=/path/to/config-dir/ ...\n</code></pre> <p>Note: <code>-agentlib</code> must be specified before a <code>-jar</code> option or a class name or any application parameters as part of the <code>java</code> command.</p> <p>When run, the agent looks up classes, methods, fields, resources for which the <code>native-image</code> tool needs additional information. When the application completes and the JVM exits, the agent writes metadata to JSON files in the specified output directory (<code>/path/to/config-dir/</code>).</p> <p>It may be necessary to run the application more than once (with different execution paths) for improved coverage of dynamic features. The <code>config-merge-dir</code> option adds to an existing set of configuration files, as follows:</p> <pre><code>$JAVA_HOME/bin/java -agentlib:native-image-agent=config-merge-dir=/path/to/config-dir/ ...                                                              ^^^^^\n</code></pre> <p>The agent also provides the following options to write metadata on a periodic basis: - <code>config-write-period-secs=n</code>: writes metadata files every <code>n</code> seconds; <code>n</code> must be greater than 0. - <code>config-write-initial-delay-secs=n</code>: waits <code>n</code> seconds before first writing metadata; defaults to <code>1</code>.</p> <p>For example:</p> <pre><code>$JAVA_HOME/bin/java -agentlib:native-image-agent=config-output-dir=/path/to/config-dir/,config-write-period-secs=300,config-write-initial-delay-secs=5 ...\n</code></pre> <p>The above command will write metadata files to <code>/path/to/config-dir/</code> every 300 seconds after an initial delay of 5 seconds.</p> <p>It is advisable to manually review the generated configuration files. Because the agent observes only executed code, the application input should cover as many code paths as possible.</p> <p>The generated configuration files can be supplied to the <code>native-image</code> tool by placing them in a <code>META-INF/native-image/</code> directory on the class path.  This directory (or any of its subdirectories) is searched for files with the names <code>jni-config.json</code>, <code>reflect-config.json</code>, <code>proxy-config.json</code>, <code>resource-config.json</code>, <code>predefined-classes-config.json</code>, <code>serialization-config.json</code> which are then automatically included in the build process.  Not all of those files must be present.  When multiple files with the same name are found, all of them are considered.</p> <p>To test the agent collecting metadata on an example application, go to the Build a Native Executable with Reflection guide.</p>"},{"location":"#conditional-metadata-collection","title":"Conditional Metadata Collection","text":"<p>The agent can deduce metadata conditions based on their usage in executed code. Conditional metadata is mainly aimed towards library maintainers with the goal of reducing overall footprint.</p> <p>To collect conditional metadata with the agent, see Conditional Metadata Collection.</p>"},{"location":"#agent-advanced-usage","title":"Agent Advanced Usage","text":""},{"location":"#caller-based-filters","title":"Caller-based Filters","text":"<p>By default, the agent filters dynamic accesses which Native Image supports without configuration. The filter mechanism works by identifying the Java method performing the access, also referred to as caller method, and matching its declaring class against a sequence of filter rules. The built-in filter rules exclude dynamic accesses which originate in the JVM, or in parts of a Java class library directly supported by Native Image (such as <code>java.nio</code>) from the generated configuration files. Which item (class, method, field, resource, etc.) is being accessed is not relevant for filtering.</p> <p>In addition to the built-in filter, custom filter files with additional rules can be specified using the <code>caller-filter-file</code> option. For example: <code>-agentlib:caller-filter-file=/path/to/filter-file,config-output-dir=...</code></p> <p>Filter files have the following structure:</p> <pre><code>{ \"rules\": [\n    {\"excludeClasses\": \"com.oracle.svm.**\"},\n    {\"includeClasses\": \"com.oracle.svm.tutorial.*\"},\n    {\"excludeClasses\": \"com.oracle.svm.tutorial.HostedHelper\"}\n  ],\n  \"regexRules\": [\n    {\"includeClasses\": \".*\"},\n    {\"excludeClasses\": \".*\\\\$\\\\$Generated[0-9]+\"}\n  ]\n}\n</code></pre> <p>The <code>rules</code> section contains a sequence of rules. Each rule specifies either <code>includeClasses</code>, which means that lookups originating in matching classes will be included in the resulting configuration, or <code>excludeClasses</code>, which excludes lookups originating in matching classes from the configuration. Each rule defines a pattern to match classes. The pattern can end in <code>.*</code> or <code>.**</code>, interpreted as follows:     - <code>.*</code> matches all classes in the package and only that package;     - <code>.**</code> matches all classes in the package as well as in all subpackages at any depth.  Without <code>.*</code> or <code>.**</code>, the rule applies only to a single class with the qualified name that matches the pattern. All rules are processed in the sequence in which they are specified, so later rules can partially or entirely override earlier ones. When multiple filter files are provided (by specifying multiple <code>caller-filter-file</code> options), their rules are chained together in the order in which the files are specified. The rules of the built-in caller filter are always processed first, so they can be overridden in custom filter files.</p> <p>In the example above, the first rule excludes lookups originating in all classes from package <code>com.oracle.svm</code> and from all of its subpackages (and their subpackages, etc.) from the generated metadata. In the next rule however, lookups from those classes that are directly in package <code>com.oracle.svm.tutorial</code> are included again. Finally, lookups from the <code>HostedHelper</code> class is excluded again. Each of these rules partially overrides the previous ones. For example, if the rules were in the reverse order, the exclusion of <code>com.oracle.svm.**</code> would be the last rule and would override all other rules.</p> <p>The <code>regexRules</code> section also contains a sequence of rules. Its structure is the same as that of the <code>rules</code> section, but rules are specified as regular expression patterns which are matched against the entire fully qualified class identifier. The <code>regexRules</code> section is optional. If a <code>regexRules</code> section is specified, a class will be considered included if (and only if) both <code>rules</code> and <code>regexRules</code> include the class and neither of them exclude it. With no <code>regexRules</code> section, only the <code>rules</code> section determines whether a class is included or excluded.</p> <p>For testing purposes, the built-in filter for Java class library lookups can be disabled by adding the <code>no-builtin-caller-filter</code> option, but the resulting metadata files are generally unsuitable for the build. Similarly, the built-in filter for Java VM-internal accesses based on heuristics can be disabled with <code>no-builtin-heuristic-filter</code> and will also generally lead to less usable metadata files. For example: <code>-agentlib:native-image-agent=no-builtin-caller-filter,no-builtin-heuristic-filter,config-output-dir=...</code></p>"},{"location":"#access-filters","title":"Access Filters","text":"<p>Unlike the caller-based filters described above, which filter dynamic accesses based on where they originate, access filters apply to the target of the access. Therefore, access filters enable directly excluding packages and classes (and their members) from the generated configuration.</p> <p>By default, all accessed classes (which also pass the caller-based filters and the built-in filters) are included in the generated configuration. Using the <code>access-filter-file</code> option, a custom filter file that follows the file structure described above can be added. The option can be specified more than once to add multiple filter files and can be combined with the other filter options, for example, <code>-agentlib:access-filter-file=/path/to/access-filter-file,caller-filter-file=/path/to/caller-filter-file,config-output-dir=...</code>.</p>"},{"location":"#specify-configuration-files-as-arguments","title":"Specify Configuration Files as Arguments","text":"<p>A directory containing configuration files that is not part of the class path can be specified to <code>native-image</code> via <code>-H:ConfigurationFileDirectories=/path/to/config-dir/</code>. This directory must directly contain all files: <code>jni-config.json</code>, <code>reflect-config.json</code>, <code>proxy-config.json</code> and <code>resource-config.json</code>. A directory with the same metadata files that is on the class path, but not in <code>META-INF/native-image/</code>, can be provided via <code>-H:ConfigurationResourceRoots=path/to/resources/</code>. Both <code>-H:ConfigurationFileDirectories</code> and <code>-H:ConfigurationResourceRoots</code> can also take a comma-separated list of directories.</p>"},{"location":"#injecting-the-agent-via-the-process-environment","title":"Injecting the Agent via the Process Environment","text":"<p>Altering the <code>java</code> command line to inject the agent can prove to be difficult if the Java process is launched by an application or script file, or if Java is even embedded in an existing process. In that case, it is also possible to inject the agent via the <code>JAVA_TOOL_OPTIONS</code> environment variable. This environment variable can be picked up by multiple Java processes which run at the same time, in which case each agent must write to a separate output directory with <code>config-output-dir</code>. (The next section describes how to merge sets of configuration files.) In order to use separate paths with a single global <code>JAVA_TOOL_OPTIONS</code> variable, the agent's output path options support placeholders:</p> <pre><code>export JAVA_TOOL_OPTIONS=\"-agentlib:native-image-agent=config-output-dir=/path/to/config-output-dir-{pid}-{datetime}/\"\n</code></pre> <p>The <code>{pid}</code> placeholder is replaced with the process identifier, while <code>{datetime}</code> is replaced with the system date and time in UTC, formatted according to ISO 8601.  For the above example, the resulting path could be: <code>/path/to/config-output-dir-31415-20181231T235950Z/</code>.</p>"},{"location":"#trace-files","title":"Trace Files","text":"<p>In the examples above, <code>native-image-agent</code> has been used to both keep track of the dynamic accesses on a JVM and then to generate a set of configuration files from them. However, for a better understanding of the execution, the agent can also write a trace file in JSON format that contains each individual access:</p> <pre><code>$JAVA_HOME/bin/java -agentlib:native-image-agent=trace-output=/path/to/trace-file.json ...\n</code></pre> <p>The <code>native-image-configure</code> tool can transform trace files to configuration files. The following command reads and processes <code>trace-file.json</code> and generates a set of configuration files in the directory <code>/path/to/config-dir/</code>:</p> <pre><code>native-image-configure generate --trace-input=/path/to/trace-file.json --output-dir=/path/to/config-dir/\n</code></pre>"},{"location":"#interoperability","title":"Interoperability","text":"<p>The agent uses the JVM Tool Interface (JVMTI) and can potentially be used with other JVMs that support JVMTI. In this case, it is necessary to provide the absolute path of the agent:</p> <pre><code>/path/to/some/java -agentpath:/path/to/graalvm/jre/lib/amd64/libnative-image-agent.so=&lt;options&gt; ...\n</code></pre>"},{"location":"#experimental-options","title":"Experimental Options","text":"<p>The agent has options which are currently experimental and might be enabled in future releases, but can also be changed or removed entirely. See the ExperimentalAgentOptions.md guide.</p>"},{"location":"#native-image-configure-tool","title":"Native Image Configure Tool","text":"<p>When using the agent in multiple processes at the same time as described in the previous section, <code>config-output-dir</code> is a safe option, but it results in multiple sets of configuration files. The <code>native-image-configure</code> tool can be used to merge these configuration files. This tool must first be built with:</p> <pre><code>native-image --macro:native-image-configure-launcher\n</code></pre> <p>Then, the tool can be used to merge sets of configuration files as follows:</p> <pre><code>native-image-configure generate --input-dir=/path/to/config-dir-0/ --input-dir=/path/to/config-dir-1/ --output-dir=/path/to/merged-config-dir/\n</code></pre> <p>This command reads one set of configuration files from <code>/path/to/config-dir-0/</code> and another from <code>/path/to/config-dir-1/</code> and then writes a set of configuration files that contains both of their information to <code>/path/to/merged-config-dir/</code>. An arbitrary number of <code>--input-dir</code> arguments with sets of configuration files can be specified. See <code>native-image-configure help</code> for all options.</p>"},{"location":"#native-image-build-configuration","title":"Native Image Build Configuration","text":"<p>Native Image supports a wide range of options to configure the <code>native-image</code> builder.</p>"},{"location":"#table-of-contents_1","title":"Table of Contents","text":"<ul> <li>Embed a Configuration File</li> <li>Configuration File Format</li> <li>Order of Arguments Evaluation</li> <li>Memory Configuration for Native Image Build</li> <li>Specify Types Required to Be Defined at Build Time</li> </ul>"},{"location":"#embed-a-configuration-file","title":"Embed a Configuration File","text":"<p>We recommend that you provide the configuration for the <code>native-image</code> builder by embedding a native-image.properties file into a project JAR file. The <code>native-image</code> builder will also automatically pick up all configuration options provided in the META-INF/native-image/ directory (or any of its subdirectories) and use it to construct <code>native-image</code> command-line options.</p> <p>To avoid a situation when constituent parts of a project are built with overlapping configurations, we recommended you use subdirectories within META-INF/native-image: a JAR file built from multiple maven projects cannot suffer from overlapping <code>native-image</code> configurations. For example: * foo.jar has its configurations in META-INF/native-image/foo_groupID/foo_artifactID * bar.jar has its configurations in META-INF/native-image/bar_groupID/bar_artifactID</p> <p>The JAR file that contains <code>foo</code> and <code>bar</code> will then contain both configurations without conflict. Therefore the recommended layout to store configuration data in JAR files is as follows:</p> <pre><code>META-INF/\n\u2514\u2500\u2500 native-image\n    \u2514\u2500\u2500 groupID\n        \u2514\u2500\u2500 artifactID\n            \u2514\u2500\u2500 native-image.properties\n</code></pre> <p>Note that the use of <code>${.}</code> in a native-image.properties file expands to the resource location that contains that exact configuration file. This can be useful if the native-image.properties file refers to resources within its subdirectory, for example, <code>-H:ResourceConfigurationResources=${.}/custom_resources.json</code>. Always make sure you use the option variants that take resources, that is, use <code>-H:ResourceConfigurationResources</code> instead of <code>-H:ResourceConfigurationFiles</code>. Other options that work in this context are: * <code>-H:DynamicProxyConfigurationResources</code> * <code>-H:JNIConfigurationResources</code> * <code>-H:ReflectionConfigurationResources</code> * <code>-H:ResourceConfigurationResources</code> * <code>-H:SerializationConfigurationResources</code></p> <p>By having such a composable native-image.properties file, building a native executable does not require any additional option on the command line. It is sufficient to run the following command:</p> <pre><code>$JAVA_HOME/bin/native-image -jar target/&lt;name&gt;.jar\n</code></pre> <p>To identify which configuration is applied when building a native executable, use <code>native-image --verbose</code>. This shows from where <code>native-image</code> picks up the configurations to construct the final composite configuration command-line options for the native image builder.</p> <pre><code>native-image --verbose -jar build/basic-app-0.1-all.jar\nApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/common/native-image.properties\nApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/buffer/native-image.properties\nApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/transport/native-image.properties\nApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/handler/native-image.properties\nApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/codec-http/native-image.properties\n...\nExecuting [\n    &lt;composite configuration command line options for the image builder&gt;\n]\n</code></pre> <p>Typical examples of configurations that use a configuration from META-INF/native-image can be found in Native Image configuration examples.</p>"},{"location":"#configuration-file-format","title":"Configuration File Format","text":"<p>A native-image.properties file is a Java properties file that specifies configurations for <code>native-image</code>.  The following properties are supported.</p> <p>Args</p> <p>Use this property if your project requires custom <code>native-image</code> command-line options to build correctly. For example, the <code>native-image-configure-examples/configure-at-runtime-example</code> contains <code>Args = --initialize-at-build-time=com.fasterxml.jackson.annotation.JsonProperty$Access</code> in its native-image.properties file to ensure the class <code>com.fasterxml.jackson.annotation.JsonProperty$Access</code> is initialized at executable build time.</p> <p>JavaArgs</p> <p>Sometimes it can be necessary to provide custom options to the JVM that runs the <code>native-image</code> builder. Use the <code>JavaArgs</code> property in this case.</p> <p>ImageName</p> <p>This property specifies a user-defined name for the executable. If <code>ImageName</code> is not used, a name is automatically chosen:     * <code>native-image -jar &lt;name.jar&gt;</code> has a default executable name <code>&lt;name&gt;</code>     * <code>native-image -cp ... fully.qualified.MainClass</code> has a default executable name <code>fully.qualified.mainclass</code></p> <p>Note that using <code>ImageName</code> does not prevent you from overriding the name via the command line. For example, if <code>foo.bar</code> contains <code>ImageName=foo_app</code>:     * <code>native-image -jar foo.bar</code> generates the executable <code>foo_app</code> but     * <code>native-image -jar foo.bar application</code> generates the executable <code>application</code></p>"},{"location":"#changing-the-default-configuration-directory","title":"Changing the Default Configuration Directory","text":"<p>Native Image by default stores configuration information in the user's home directory: $HOME/.native-image/. To change this default, set the environment variable <code>NATIVE_IMAGE_USER_HOME</code> to a different location. For example:</p> <pre><code>export NATIVE_IMAGE_USER_HOME= $HOME/.local/share/native-image\n</code></pre>"},{"location":"#order-of-arguments-evaluation","title":"Order of Arguments Evaluation","text":"<p>The options passed to <code>native-image</code> are evaluated from left to right. This also extends to options that are passed indirectly via configuration files in the META-INF/native-image directory. Consider the example where there is a JAR file that includes native-image.properties containing <code>Args = -H:Optimize=0</code>. You can override the setting that is contained in the JAR file by using the <code>-H:Optimize=2</code> option after <code>-cp &lt;jar-file&gt;</code>.</p>"},{"location":"#memory-configuration-for-native-image-build","title":"Memory Configuration for Native Image Build","text":"<p>The <code>native-image</code> builder runs on a JVM and uses the memory management of the underlying platform. The usual Java command-line options for garbage collection apply to the <code>native-image</code> builder.</p> <p>During the creation of a native executable, the representation of the whole application is created to determine which classes and methods will be used at runtime. It is a computationally intensive process that uses the following default values for memory usage:</p> <pre><code>-Xss10M \\\n-XX:MaxRAMPercentage=&lt;percentage based on available memory&gt; \\\n-XX:GCTimeRatio=19 \\\n-XX:+ExitOnOutOfMemoryError \\\n</code></pre> <p>These defaults can be changed by passing <code>-J + &lt;jvm option for memory&gt;</code> to the <code>native-image</code> tool.</p> <p>The <code>-XX:MaxRAMPercentage</code> value determines the maximum heap size of the builder and is computed based on available memory of the system. It maxes out at 32GB by default and can be overwritten with, for example, <code>-J-XX:MaxRAMPercentage=90.0</code> for 90% of physical memory or <code>-Xmx4g</code> for 4GB. <code>-XX:GCTimeRatio=19</code> increases the goal of the total time for garbage collection to 5%, which is more throughput-oriented and reduces peak RSS. The build process also exits on the first <code>OutOfMemoryError</code> (<code>-XX:+ExitOnOutOfMemoryError</code>) to provide faster feedback in environments under a lot of memory pressure.</p> <p>By default, the <code>native-image</code> tool uses up to 32 threads (but not more than the number of processors available). For custom values, use the <code>--parallelism=...</code> option.</p> <p>For other related options available to the <code>native-image</code> tool, see the output from the command <code>native-image --expert-options-all</code>.</p>"},{"location":"#specify-types-required-to-be-defined-at-build-time","title":"Specify Types Required to Be Defined at Build Time","text":"<p>A well-structured library or application should handle linking of Java types (ensuring all reachable Java types are fully defined at build time) when building a native binary by itself. The default behavior is to throw linking errors, if they occur, at runtime.  However, you can prevent unwanted linking errors by specifying which classes are required to be fully linked at build time. For that, use the <code>--link-at-build-time</code> option.  If the option is used in the right context (see below), you can specify required classes to link at build time without explicitly listing classes and packages. It is designed in a way that libraries can only configure their own classes, to avoid any side effects on other libraries. You can pass the option to the <code>native-image</code> tool on the command line, embed it in a <code>native-image.properties</code> file on the module-path or the classpath.</p> <p>Depending on how and where the option is used it behaves differently:</p> <ul> <li>If you use <code>--link-at-build-time</code> without arguments, all classes in the scope are required to be fully defined. If used without arguments on command line, all classes will be treated as \"link-at-build-time\" classes. If used without arguments embedded in a <code>native-image.properties</code> file on the module-path, all classes of the module will be treated as \"link-at-build-time\" classes. If you use <code>--link-at-build-time</code> embedded in a <code>native-image.properties</code> file on the classpath, the following error will be thrown:     <code>shell     Error: Using '--link-at-build-time' without args only allowed on module-path. 'META-INF/native-image/org.mylibrary/native-image.properties' in 'file:///home/test/myapp/MyLibrary.jar' not part of module-path.</code></li> <li>If you use the  <code>--link-at-build-time</code> option with arguments, for example, <code>--link-at-build-time=foo.bar.Foobar,demo.myLibrary.Name,...</code>, the arguments should be fully qualified class names or package names. When used on the module-path or classpath (embedded in <code>native-image.properties</code> files), only classes and packages defined in the same JAR file can be specified. Packages for libraries used on the classpath need to be listed explicitly. To make this process easy, use the <code>@&lt;prop-values-file&gt;</code> syntax to generate a package list (or a class list) in a separate file automatically.</li> </ul> <p>Another handy option is <code>--link-at-build-time-paths</code> which allows to specify which classes are required to be fully defined at build time by other means. This variant requires arguments that are of the same type as the arguments passed via <code>-p</code> (<code>--module-path</code>) or <code>-cp</code> (<code>--class-path</code>):</p> <pre><code>--link-at-build-time-paths &lt;class search path of directories and zip/jar files&gt;\n</code></pre> <p>The given entries are searched and all classes inside are registered as <code>--link-at-build-time</code> classes. This option is only allowed to be used on command line.</p>"},{"location":"#related-documentation","title":"Related Documentation","text":"<ul> <li>Class Initialization in Native Image</li> <li>Native Image Basics</li> <li>Native Image Build Options</li> <li>Native Image Build Overview</li> <li>Reachability Metadata</li> </ul>"},{"location":"#native-image-build-options","title":"Native Image Build Options","text":"<p>Depending on the GraalVM version, the options to the <code>native-image</code> builder may differ.</p> <ul> <li><code>-cp, -classpath, --class-path &lt;class search path of directories and zip/jar files&gt;</code>: a <code>:</code> (<code>;</code> on Windows) separated list of directories, JAR archives, and ZIP archives to search for class files</li> <li><code>-p &lt;module path&gt;, --module-path &lt;module path&gt;</code>: a <code>:</code> (<code>;</code> on Windows) separated list of directories. Each directory is a directory of modules.</li> <li><code>--add-modules &lt;module name&gt;[,&lt;module name&gt;...]</code>: add root modules to resolve in addition to the initial module. <code>&lt;module name&gt;</code> can also be <code>ALL-DEFAULT</code>, <code>ALL-SYSTEM</code>, <code>ALL-MODULE-PATH</code>.</li> <li><code>-D&lt;name&gt;=&lt;value&gt;</code>: set a system property </li> <li><code>-J&lt;flag&gt;</code>: pass an option directly to the JVM running the <code>native-image</code> builder</li> <li><code>--diagnostics-mode</code>: enable diagnostics output which includes class initialization, substitutions, etc.</li> <li><code>--enable-preview</code>: allow classes to depend on preview features of this release</li> <li><code>--verbose</code>: enable verbose output</li> <li><code>--version</code>: print the product version and exit</li> <li><code>--help</code>: print this help message</li> <li><code>--help-extra</code>: print help on non-standard options</li> <li><code>--auto-fallback</code>: build standalone native executable if possible</li> <li><code>--configure-reflection-metadata</code>: enable runtime instantiation of reflection objects for non-invoked methods</li> <li><code>--enable-all-security-services</code>: add all security service classes to a generated native executable</li> <li><code>--enable-http</code>: enable HTTP support in a native executable</li> <li><code>--enable-https</code>: enable HTTPS support in a native executable</li> <li><code>--enable-monitoring</code>: enable monitoring features that allow the VM to be inspected at run time. A comma-separated list can contain <code>heapdump</code>, <code>jfr</code>, <code>jvmstat</code>, <code>jmxserver</code> (experimental), <code>jmxclient</code> (experimental), or <code>all</code> (deprecated behavior: defaults to <code>all</code> if no argument is provided). For example: <code>--enable-monitoring=heapdump,jfr</code>.</li> <li><code>--enable-sbom</code>: embed a Software Bill of Materials (SBOM) in a native executable or shared library for passive inspection. A comma-separated list can contain <code>cyclonedx</code>, <code>strict</code> (defaults to <code>cyclonedx</code> if no argument is provided), or <code>export</code> to save the SBOM to the native executable's output directory. The optional <code>strict</code> flag aborts the build if any class cannot be matched to a library in the SBOM. For example: <code>--enable-sbom=cyclonedx,strict</code>. (Not available in GraalVM Community Edition.)</li> <li><code>--enable-url-protocols</code>: list comma-separated URL protocols to enable</li> <li><code>--features</code>: a comma-separated list of fully qualified Feature implementation classes</li> <li><code>--force-fallback</code>: force building of a fallback native executable</li> <li><code>--gc=&lt;value&gt;</code>: select Native Image garbage collector implementation. Allowed options for <code>&lt;value&gt;</code> are: <code>G1</code> for G1 garbage collector (not available in GraalVM Community Edition); <code>epsilon</code> for Epsilon garbage collector; <code>serial</code> for Serial garbage collector (default).</li> <li><code>--initialize-at-build-time</code>: a comma-separated list of packages and classes (and implicitly all of their superclasses) that are initialized during generation of a native executable. An empty string designates all packages.</li> <li><code>--initialize-at-run-time</code>: a comma-separated list of packages and classes (and implicitly all of their subclasses) that must be initialized at run time and not during generation. An empty string is currently not supported.</li> <li><code>--install-exit-handlers</code>: provide <code>java.lang.Terminator</code> exit handlers</li> <li><code>--libc</code>: select the <code>libc</code> implementation to use. Available implementations are <code>glibc</code>, <code>musl</code>, <code>bionic</code>.</li> <li><code>--link-at-build-time</code>: require types to be fully defined at executable's build time. If used without arguments, all classes in scope of the option are required to be fully defined.</li> <li><code>--link-at-build-time-paths</code>: require all types in given class or module-path entries to be fully defined at at executable's build time</li> <li><code>--list-cpu-features</code>: show CPU features specific to the target platform and exit</li> <li><code>--list-modules</code>: list observable modules and exit</li> <li><code>--native-compiler-options</code>: provide a custom C compiler option used for query code compilation</li> <li><code>--native-compiler-path</code>: provide a custom path to the C compiler used to query code compilation and linking</li> <li><code>--native-image-info</code>: show the native toolchain information and executable's build settings</li> <li><code>--no-fallback</code>: build a standalone native executable or report a failure</li> <li><code>--pgo</code>: a comma-separated list of files from which to read the data collected for profile-guided optimizations of AOT-compiled code (reads from  default.iprof if nothing is specified). (Not available in GraalVM Community Edition.)</li> <li><code>--pgo-instrument</code>: instrument AOT-compiled code to collect data for profile-guided optimizations into the default.iprof file. (Not available in GraalVM Community Edition.)</li> <li><code>--report-unsupported-elements-at-runtime</code>: report the usage of unsupported methods and fields at run time when they are accessed the first time, instead of an error during executable's building</li> <li><code>--shared</code>: build a shared library</li> <li><code>--silent</code>: silence build output</li> <li><code>--static</code>: build a statically-linked executable (requires <code>libc</code> and <code>zlib</code> static libraries)</li> <li><code>--target</code>: select the compilation target for <code>native-image</code> (in - format). It defaults to host's OS-architecture pair. <li><code>--trace-class-initialization</code>: provide a comma-separated list of fully-qualified class names that a class initialization is traced for</li> <li><code>--trace-object-instantiation</code>: provide a comma-separated list of fully-qualified class names that an object instantiation is traced for</li> <li><code>-O&lt;level&gt;</code>: control code optimizations where available variants are <code>b</code> for quick build mode for development, <code>0</code> - no optimizations, <code>1</code> - basic optimizations, <code>2</code> - aggressive optimizations (default)</li> <li><code>-da</code>, <code>-da[:[packagename]|:[classname]</code>, <code>disableassertions[:[packagename]|:[classname]</code>: disable assertions with specified granularity at run time</li> <li><code>-dsa</code>, <code>-disablesystemassertions</code>: disable assertions in all system classes at run time</li> <li><code>-ea</code>, <code>-ea[:[packagename]|:[classname]</code>, <code>enableassertions[:[packagename]|:[classname]</code>: enable assertions with specified granularity at run time</li> <li><code>-esa</code>, <code>-enablesystemassertions</code>: enable assertions in all system classes at run time</li> <li><code>-g</code>: generate debugging information</li> <li><code>-march</code>: generate instructions for a specific machine type. Defaults to <code>x86-64-v3</code> on AMD64 and <code>armv8-a</code> on AArch64. Use <code>-march=compatibility</code> for best compatibility, or <code>-march=native</code> for best performance if a native executable is deployed on the same machine or on a machine with the same CPU features. To list all available machine types, use <code>-march=list</code>.</li> <li><code>-o</code>: name of the output file to be generated</li>"},{"location":"#macro-options","title":"Macro Options","text":"<ul> <li><code>--language:nfi</code>: make the Truffle Native Function Interface language available</li> <li><code>--tool:coverage</code>: add source code coverage support to a GraalVM-supported language</li> <li><code>--tool:insight</code>: add support for detailed access to program's runtime behavior, allowing users to inspect values and types at invocation or allocation sites</li> <li><code>--tool:dap</code>: allow image to open a debugger port serving the Debug Adapter Protocol in IDEs like Visual Studio Code</li> <li><code>--tool:chromeinspector</code>: add debugging support to a GraalVM-supported language</li> <li><code>--tool:insightheap</code>: snapshot a region of image heap during the execution</li> <li><code>--tool:lsp</code>: add the Language Server Protocol support to later attach compatible debuggers to GraalVM in IDEs like Visual Studio Code</li> <li><code>--tool:sandbox</code>: enables the Truffle sandbox resource limits. For more information, check the dedicated documentation</li> <li><code>--tool:profiler</code>: add profiling support to a GraalVM-supported language</li> </ul> <p>The <code>--language:js</code> <code>--language:nodejs</code>, <code>--language:python</code>, <code>--language:ruby</code>, <code>--language:R</code>, <code>--language:wasm</code>, <code>--language:llvm</code>, <code>--language:regex</code> (enables the Truffle Regular Expression engine) polyglot macro options become available once the corresponding languages are added to the base GraalVM JDK.</p>"},{"location":"#non-standard-options","title":"Non-standard Options","text":"<p>Run <code>native-image --help-extra</code> for non-standard options help.</p> <ul> <li><code>--expert-options</code>: list image build options for experts</li> <li><code>--expert-options-all</code>: list all image build options for experts (use at your own risk). Options marked with Extra help available contain help that can be shown with <code>--expert-options-detail</code></li> <li><code>--expert-options-detail</code>: display all available help for a comma-separated list of option names. Pass <code>*</code> to show extra help for all options that contain it.</li> <li><code>--configurations-path &lt;search path of option-configuration directories&gt;</code>: a separated list of directories to be treated as option-configuration directories.</li> <li><code>--debug-attach[=&lt; port (* can be used as host meaning bind to all interfaces)&gt;]</code>: attach to debugger during image building (default port is 8000)</li> <li><code>--diagnostics-mode</code>: Enables logging of image-build information to a diagnostics folder.</li> <li><code>--dry-run</code>: output the command line that would be used for building</li> <li><code>--bundle-create[=new-bundle.nib]</code>: in addition to image building, create a native image bundle file (*.nibfile) that allows rebuilding of that image again at a later point. If a bundle-file gets passed the bundle will be created with the given name. Otherwise, the bundle-file name is derived from the image name. Note both bundle options can be combined with <code>--dry-run</code> to only perform the bundle operations without any actual image building.</li> <li><code>--bundle-apply=some-bundle.nib</code>: an image will be built from the given bundle file with the exact same arguments and files that have been passed to Native Image originally to create the bundle. Note that if an extra <code>--bundle-create</code> gets passed after <code>--bundle-apply</code>, a new bundle will be written based on the given bundle args plus any additional arguments that haven been passed afterwards. For example: <code>native-image --bundle-apply=app.nib --bundle-create=app_dbg.nib -g</code> creates a new bundle   based on the given app.nib bundle. Both bundles are the same except the new one also uses the -g option. <li><code>-E&lt;env-var-key&gt;[=&lt;env-var-value&gt;]</code>: allow Native Image to access the given environment variable during image build. If the optional  is not given, the value of the environment variable will be taken from the environment Native Image was invoked from. <li><code>-V&lt;key&gt;=&lt;value&gt;</code>:  provide values for placeholders in <code>native-image.properties</code> files</li> <li><code>--add-exports</code>: value <code>&lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)</code> updates <code>&lt;module&gt;</code> to export <code>&lt;package&gt;</code> to <code>&lt;target-module&gt;</code>, regardless of module declaration. <code>&lt;target-module&gt;</code> can be <code>ALL-UNNAMED</code> to export to all unnamed modules</li> <li><code>--add-opens</code>: value <code>&lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)</code> updates <code>&lt;module&gt;</code> to open <code>&lt;package&gt;</code> to <code>&lt;target-module&gt;</code>, regardless of module declaration. </li> <li><code>--add-reads</code>: value <code>&lt;module&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)</code> updates <code>&lt;module&gt;</code> to read <code>&lt;target-module&gt;</code>, regardless of module declaration. <code>&lt;target-module&gt;</code> can be <code>ALL-UNNAMED</code> to read all unnamed modules.</li> <p>Native Image options are also distinguished as hosted and runtime options.</p>"},{"location":"#native-image-build-output","title":"Native Image Build Output","text":"<ul> <li>Build Stages</li> <li>Resource Usage Statistics</li> <li>Machine-Readable Build Output</li> </ul> <p>Here you will find information about the build output of GraalVM Native Image. Below is the example output when building a native executable of the <code>HelloWorld</code> class:</p> <pre><code>================================================================================\nGraalVM Native Image: Generating 'helloworld' (executable)...\n================================================================================\n[1/8] Initializing...                                            (2.8s @ 0.15GB)\n Java version: 20+34, vendor version: GraalVM CE 20-dev+34.1\n Graal compiler: optimization level: 2, target machine: x86-64-v3\n C compiler: gcc (linux, x86_64, 12.2.0)\n Garbage collector: Serial GC (max heap size: 80% of RAM)\n--------------------------------------------------------------------------------\n Build resources:\n - 13.24GB of memory (42.7% of 31.00GB system memory, determined at start)\n - 16 thread(s) (100.0% of 16 available processor(s), determined at start)\n[2/8] Performing analysis...  [****]                             (4.5s @ 0.54GB)\n    3,163 reachable types   (72.5% of    4,364 total)\n    3,801 reachable fields  (50.3% of    7,553 total)\n   15,183 reachable methods (45.5% of   33,405 total)\n      957 types,    81 fields, and   480 methods registered for reflection\n       57 types,    55 fields, and    52 methods registered for JNI access\n        4 native libraries: dl, pthread, rt, z\n[3/8] Building universe...                                       (0.8s @ 0.99GB)\n[4/8] Parsing methods...      [*]                                (0.6s @ 0.75GB)\n[5/8] Inlining methods...     [***]                              (0.3s @ 0.32GB)\n[6/8] Compiling methods...    [**]                               (3.7s @ 0.60GB)\n[7/8] Layouting methods...    [*]                                (0.8s @ 0.83GB)\n[8/8] Creating image...       [**]                               (3.1s @ 0.58GB)\n   5.32MB (24.22%) for code area:     8,702 compilation units\n   7.03MB (32.02%) for image heap:   93,301 objects and 5 resources\n   8.96MB (40.83%) for debug info generated in 1.0s\n 659.13kB ( 2.93%) for other data\n  21.96MB in total\n--------------------------------------------------------------------------------\nTop 10 origins of code area:            Top 10 object types in image heap:\n   4.03MB java.base                        1.14MB byte[] for code metadata\n 927.05kB svm.jar (Native Image)         927.31kB java.lang.String\n 111.71kB java.logging                   839.68kB byte[] for general heap data\n  63.38kB org.graalvm.nativeimage.base   736.91kB java.lang.Class\n  47.59kB jdk.proxy1                     713.13kB byte[] for java.lang.String\n  35.85kB jdk.proxy3                     272.85kB c.o.s.c.h.DynamicHubCompanion\n  27.06kB jdk.internal.vm.ci             250.83kB java.util.HashMap$Node\n  23.44kB org.graalvm.sdk                196.52kB java.lang.Object[]\n  11.42kB jdk.proxy2                     182.77kB java.lang.String[]\n   8.07kB jdk.internal.vm.compiler       154.26kB byte[] for embedded resources\n   1.39kB for 2 more packages              1.38MB for 884 more object types\n--------------------------------------------------------------------------------\nRecommendations:\n HEAP: Set max heap for improved and more predictable memory usage.\n CPU:  Enable more CPU features with '-march=native' for improved performance.\n--------------------------------------------------------------------------------\n    0.8s (4.6% of total time) in 35 GCs | Peak RSS: 1.93GB | CPU load: 9.61\n--------------------------------------------------------------------------------\nProduced artifacts:\n /home/janedoe/helloworld/helloworld (executable)\n /home/janedoe/helloworld/helloworld.debug (debug_info)\n /home/janedoe/helloworld/sources (debug_info)\n================================================================================\nFinished generating 'helloworld' in 17.0s.\n</code></pre>"},{"location":"#build-stages","title":"Build Stages","text":""},{"location":"#initializing","title":"Initializing","text":"<p>In this stage, the Native Image build process is set up and <code>Features</code> are initialized.</p>"},{"location":"#native-image-kind","title":"Native Image Kind","text":"<p>By default, Native Image generates executables but it can also generate native shared libraries and static executables.</p>"},{"location":"#java-version-info","title":"Java Version Info","text":"<p>The Java and vendor version of the Native Image process. Both are also used for the <code>java.vm.version</code> and <code>java.vendor.version</code> properties within the generated native binary. Please report version and vendor when you file issues.</p>"},{"location":"#graal-compiler","title":"Graal Compiler","text":"<p>The selected optimization level and targeted machine type used by the Graal compiler. The optimization level can be controlled with the <code>-O</code> option and defaults to <code>2</code>, which enables aggressive optimizations. Use <code>-Ob</code> to enable quick build mode, which speeds up the compilation stage. This is useful during development, or when peak throughput is less important and you would like to optimize for size. The targeted machine type can be selected with the <code>-march</code> option and defaults to <code>x86-64-v3</code> on AMD64 and <code>armv8-a</code> on AArch64. See here for recommendations on how to use this option.</p> <p>On Oracle GraalVM, the line also shows information about Profile-Guided Optimizations (PGO). - <code>off</code>: PGO is not used - <code>instrument</code>: The generated executable or shared library is instrumented to collect data for PGO (<code>--pgo-instrument</code>) - <code>user-provided</code>: PGO is enabled and uses a user-provided profile (for example <code>--pgo default.iprof</code>) - <code>ML-inferred</code>: A machine learning (ML) model is used to infer profiles for control split branches statically.</p>"},{"location":"#c-compiler","title":"C Compiler","text":"<p>The C compiler executable, vendor, target architecture, and version info used by the Native Image build process.</p>"},{"location":"#garbage-collector","title":"Garbage Collector","text":"<p>The garbage collector used within the generated executable: - The Serial GC is the default GC and optimized for low memory footprint and small Java heap sizes. - The G1 GC (not available in GraalVM Community Edition) is a multi-threaded GC that is optimized to reduce stop-the-world pauses and therefore improve latency while achieving high throughput. - The Epsilon GC does not perform any garbage collection and is designed for very short-running applications that only allocate a small amount of memory.</p> <p>For more information see the docs on Memory Management.</p>"},{"location":"#maximum-heap-size","title":"Maximum Heap Size","text":"<p>By default, the heap size is limited to a certain percentage of your system memory, allowing the garbage collector to freely allocate memory according to its policy. Use the <code>-Xmx</code> option when invoking your native executable (for example <code>./myapp -Xmx64m</code> for 64MB) to limit the maximum heap size for a lower and more predictable memory footprint. This can also improve latency in some cases. Use the <code>-R:MaxHeapSize</code> option when building with Native Image to pre-configure the maximum heap size.</p>"},{"location":"#user-specific-features","title":"User-Specific Features","text":"<p>All <code>Features</code> that are either provided or specifically enabled by the user, or implicitly registered for the user, for example, by a framework. GraalVM Native Image deploys a number of internal features, which are excluded from this list.</p>"},{"location":"#build-resources","title":"Build Resources","text":"<p>The memory limit and number of threads used by the build process.</p> <p>More precisely, the memory limit of the Java heap, so actual memory consumption can be even higher. Please check the peak RSS reported at the end of the build to understand how much memory was actually used. By default, the process will only use available memory: memory that the operating system can make available without swapping out memory used by other processes. Therefore, consider freeing up memory if your build process is slow, for example, by closing applications that you do not need. Note that, by default, the build process will not use more than 32GB available memory.</p> <p>By default, the build process uses all available CPU cores to maximize speed. Use the <code>--parallelism</code> option to set the number of threads explicitly (for example, <code>--parallelism=4</code>). Use fewer threads to reduce load on your system as well as memory consumption (at the cost of a slower build process).</p>"},{"location":"#performing-analysis","title":"Performing Analysis","text":"<p>In this stage, a points-to analysis is performed. The progress indicator visualizes the number of analysis iterations. A large number of iterations can indicate problems in the analysis likely caused by misconfiguration or a misbehaving feature.</p>"},{"location":"#reachable-types-fields-and-methods","title":"Reachable Types, Fields, and Methods","text":"<p>The number of types (primitives, classes, interfaces, and arrays), fields, and methods that are reachable versus the total number of types, fields, and methods loaded as part of the build process. A significantly larger number of loaded elements that are not reachable can indicate a configuration problem. To reduce overhead, please ensure that your class path and module path only contain entries that are needed for building the application.</p>"},{"location":"#reflection-registrations","title":"Reflection Registrations","text":"<p>The number of types, fields, and methods that are registered for reflection. Large numbers can cause significant reflection overheads, slow down the build process, and increase the size of the native binary (see reflection metadata).</p>"},{"location":"#jni-access-registrations","title":"JNI Access Registrations","text":"<p>The number of types, fields, and methods that are registered for JNI access.</p>"},{"location":"#runtime-compiled-methods","title":"Runtime Compiled Methods","text":"<p>The number of methods marked for runtime compilation. This number is only shown if runtime compilation is built into the executable, for example, when building a Truffle language. Runtime-compiled methods account for graph encodings in the heap.</p>"},{"location":"#building-universe","title":"Building Universe","text":"<p>In this stage, a universe with all types, fields, and methods is built, which is then used to create the native binary.</p>"},{"location":"#parsing-methods","title":"Parsing Methods","text":"<p>In this stage, the Graal compiler parses all reachable methods. The progress indicator is printed periodically at an increasing interval.</p>"},{"location":"#inlining-methods","title":"Inlining Methods","text":"<p>In this stage, trivial method inlining is performed. The progress indicator visualizes the number of inlining iterations.</p>"},{"location":"#compiling-methods","title":"Compiling Methods","text":"<p>In this stage, the Graal compiler compiles all reachable methods to machine code. The progress indicator is printed periodically at an increasing interval.</p>"},{"location":"#layouting-methods","title":"Layouting Methods","text":"<p>In this stage, compiled methods are layouted. The progress indicator is printed periodically at an increasing interval.</p>"},{"location":"#creating-image","title":"Creating Image","text":"<p>In this stage, the native binary is created and written to disk. Debug info is also generated as part of this stage (if requested).</p>"},{"location":"#code-area","title":"Code Area","text":"<p>The code area contains machine code produced by the Graal compiler for all reachable methods. Therefore, reducing the number of reachable methods also reduces the size of the code area.</p>"},{"location":"#origins-of-code-area","title":"Origins of Code Area","text":"<p>To help users understand where the machine code of the code area comes from, the build output shows a breakdown of the top origins. An origin is a group of Java sources and can be a JAR file, a package name, or a class name, depending on the information available. The <code>java.base</code> module, for example, contains base classes from the JDK. The <code>svm.jar</code> file, the <code>org.graalvm.nativeimage.base</code> module, and similar origins contain internal sources for the Native Image runtime. To reduce the size of the code area and with that, the total size of the native executable, re-evaluate the dependencies of your application based on the code area breakdown. Some libraries and frameworks are better prepared for Native Image than others, and newer versions of a library or framework may improve (or worsen) their code footprint. </p>"},{"location":"#image-heap","title":"Image Heap","text":"<p>The heap contains reachable objects such as static application data, metadata, and <code>byte[]</code> for different purposes (see below).</p>"},{"location":"#general-heap-data-stored-in-byte","title":"General Heap Data Stored in <code>byte[]</code>","text":"<p>The total size of all <code>byte[]</code> objects that are neither used for <code>java.lang.String</code>, nor code metadata, nor reflection metadata, nor graph encodings. Therefore, this can also include <code>byte[]</code> objects from application code.</p>"},{"location":"#embedded-resources-stored-in-byte","title":"Embedded Resources Stored in <code>byte[]</code>","text":"<p>The total size of all <code>byte[]</code> objects used for storing resources (for example, files accessed via <code>Class.getResource()</code>) within the native binary. The number of resources is shown in the Heap section.</p>"},{"location":"#code-metadata-stored-in-byte","title":"Code Metadata Stored in <code>byte[]</code>","text":"<p>The total size of all <code>byte[]</code> objects used for metadata for the code area. Therefore, reducing the number of reachable methods also reduces the size of this metadata.</p>"},{"location":"#reflection-metadata-stored-in-byte","title":"Reflection Metadata Stored in <code>byte[]</code>","text":"<p>The total size of all <code>byte[]</code> objects used for reflection metadata, including types, field, method, and constructor data. To reduce the amount of reflection metadata, reduce the number of elements registered for reflection.</p>"},{"location":"#graph-encodings-stored-in-byte","title":"Graph Encodings Stored in <code>byte[]</code>","text":"<p>The total size of all <code>byte[]</code> objects used for graph encodings. These encodings are a result of runtime compiled methods. Therefore, reducing the number of such methods also reduces the size of corresponding graph encodings.</p>"},{"location":"#debug-info","title":"Debug Info","text":"<p>The total size of generated debug information (if enabled).</p>"},{"location":"#other-data","title":"Other Data","text":"<p>The amount of data in the binary that is neither in the code area, nor in the heap, nor debug info. This data typically contains internal information for Native Image and should not be dominating.</p>"},{"location":"#recommendations","title":"Recommendations","text":"<p>The build output may contain one or more of the following recommendations that help you get the best out of Native Image.</p>"},{"location":"#awt-missing-reachability-metadata-for-abstract-window-toolkit","title":"<code>AWT</code>: Missing Reachability Metadata for Abstract Window Toolkit","text":"<p>The Native Image analysis has included classes from the <code>java.awt</code> package but could not find any reachability metadata for it. Use the tracing agent to collect such metadata for your application. Otherwise, your application is unlikely to work properly. If your application is not a desktop application (for example using Swing or AWT directly), you may want to re-evaluate whether the dependency on AWT is actually needed.</p>"},{"location":"#cpu-enable-more-cpu-features-for-improved-performance","title":"<code>CPU</code>: Enable More CPU Features for Improved Performance","text":"<p>The Native Image build process has determined that your CPU supports more features, such as AES or LSE, than currently enabled. If you deploy your application on the same machine or a similar machine with support for the same CPU features, consider using <code>-march=native</code> at build time. This option allows the Graal compiler to use all CPU features available, which in turn can significantly improve the performance of your application. Use <code>-march=list</code> to list all available machine types that can be targeted explicitly.</p>"},{"location":"#g1gc-use-g1-garbage-collector-for-improved-latency-and-throughput","title":"<code>G1GC</code>: Use G1 Garbage Collector for Improved Latency and Throughput","text":"<p>The G1 garbage collector is available for your platform. Consider enabling it using <code>--gc=G1</code> at build time to improve the latency and throughput of your application. For more information see the docs on Memory Management. For best peak performance, also consider using Profile-Guided Optimizations.</p>"},{"location":"#heap-specify-a-maximum-heap-size","title":"<code>HEAP</code>: Specify a Maximum Heap Size","text":"<p>Please refer to Maximum Heap Size.</p>"},{"location":"#pgo-use-profile-guided-optimizations-for-improved-throughput","title":"<code>PGO</code>: Use Profile-Guided Optimizations for Improved Throughput","text":"<p>Consider using Profile-Guided Optimizations to optimize your application for improved throughput. These optimizations allow the Graal compiler to leverage profiling information, similar to when it is running as a JIT compiler, when AOT-compiling your application. For this, perform the following steps:</p> <ol> <li>Build your application with <code>--pgo-instrument</code>.</li> <li>Run your instrumented application with a representative workload to generate profiling information in the form of an <code>.iprof</code> file.</li> <li>Re-build your application and pass in the profiling information with <code>--pgo=&lt;your&gt;.iprof</code> to generate an optimized version of your application.</li> </ol> <p>Relevant guide: Optimize a Native Executable with Profile-Guided Optimizations.</p> <p>For best peak performance, also consider using the G1 garbage collector.</p>"},{"location":"#qbm-use-quick-build-mode-for-faster-builds","title":"<code>QBM</code>: Use Quick Build Mode for Faster Builds","text":"<p>Consider using the quick build mode (<code>-Ob</code>) to speed up your builds during development. More precisely, this mode reduces the number of optimizations performed by the Graal compiler and thus reduces the overall time of the compilation stage. The quick build mode is not only useful for development, it can also cause the generated executable file to be smaller in size. Note, however, that the overall peak throughput of the executable may be lower due to the reduced number of optimizations.</p>"},{"location":"#resource-usage-statistics","title":"Resource Usage Statistics","text":""},{"location":"#garbage-collections","title":"Garbage Collections","text":"<p>The total time spent in all garbage collectors, total GC time divided by the total process time as a percentage, and the total number of garbage collections. A large number of collections or time spent in collectors usually indicates that the system is under memory pressure. Increase the amount of available memory to reduce the time to build the native binary.</p>"},{"location":"#peak-rss","title":"Peak RSS","text":"<p>Peak resident set size as reported by the operating system. This value indicates the maximum amount of memory consumed by the build process. You may want to compare this value to the memory limit reported in the build resources section. If there is enough headroom and the GC statistics do not show any problems, the amount of total memory of the system can be reduced to a value closer to the peak RSS to lower operational costs.</p>"},{"location":"#cpu-load","title":"CPU load","text":"<p>The CPU time used by the process divided by the total process time. Increase the number of CPU cores to reduce the time to build the native binary.</p>"},{"location":"#machine-readable-build-output","title":"Machine-Readable Build Output","text":"<p>The build output produced by the <code>native-image</code> builder is designed for humans, can evolve with new releases, and should thus not be parsed in any way by tools. Instead, use the <code>-H:BuildOutputJSONFile=&lt;file.json&gt;</code> option to instruct the builder to produce machine-readable build output in JSON format that can be used, for example, for building monitoring tools. The JSON files validate against the JSON schema defined in <code>build-output-schema-v0.9.2.json</code>. Note that a JSON file is produced if and only if a build succeeds.</p> <p>The following example illustrates how this could be used in a CI/CD build pipeline to check that the number of reachable methods does not exceed a certain threshold:</p> <pre><code>native-image -H:BuildOutputJSONFile=build.json HelloWorld\n# ...\ncat build.json | python3 -c \"import json,sys;c = json.load(sys.stdin)['analysis_results']['methods']['reachable']; assert c &lt; 12000, f'Too many reachable methods: {c}'\"\nTraceback (most recent call last):\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\nAssertionError: Too many reachable methods: 12128\n</code></pre>"},{"location":"#related-documentation_1","title":"Related Documentation","text":"<ul> <li>Build a Native Shared Library</li> <li>Build a Statically Linked or Mostly-Statically Linked Native Executable</li> <li>Feature</li> <li>Interoperability with Native Code</li> <li>Java Native Interface (JNI) in Native Image</li> <li>Memory Management</li> <li>Native Image Build Overview</li> <li>Native Image Build Configuration</li> </ul>"},{"location":"#native-image-build-overview","title":"Native Image Build Overview","text":"<p>The syntax of the <code>native-image</code> command is:</p> <ul> <li><code>native-image [options] &lt;mainclass&gt; [imagename] [options]</code> to build a native binary from <code>&lt;mainclass&gt;</code> class in the current working directory. The classpath may optionally be provided with the <code>-cp &lt;classpath&gt;</code> option where <code>&lt;classpath&gt;</code> is a colon-separated (on Windows, semicolon-separated) list of paths to directories and jars.</li> <li><code>native-image [options] -jar jarfile [imagename] [options]</code> to build native binary from a JAR file.</li> <li><code>native-image [options] -m &lt;module&gt;/&lt;mainClass&gt; [imagename] [options]</code> to build a native binary from a Java module.</li> </ul> <p>The options passed to <code>native-image</code> are evaluated from left to right.</p> <p>The options fall into three categories:  - Image generation options - for the full list, run <code>native-image --help</code>  - Macro options  - Non-standard options - subject to change through a deprecation cycle, run <code>native-image --help-extra</code> for the full list.</p> <p>Find a complete list of options for the <code>native-image</code> tool here.</p> <p>There are some expert level options that a Native Image developer may find useful or needed, for example, the option to dump graphs of the <code>native-image</code> builder or enable assertions at image run time. This information can be found in Native Image Hosted and Runtime Options.</p>"},{"location":"#further-reading","title":"Further Reading","text":"<p>If you are new to GraalVM Native Image or have little experience using it, see the Native Image Basics to better understand some key aspects before going further.</p> <p>For more tweaks and how to properly configure the <code>native-image</code> tool, see Build Configuration.</p> <p>Native Image will output the progress and various statistics when building the native binary. To learn more about the output, and the different build phases, see Build Output.</p>"},{"location":"#native-image-bundles","title":"Native Image Bundles","text":"<p>Native Image provides a feature that enables users to build native executables from a self-contained bundle.  In contrast to regular <code>native-image</code> building, this mode of operation takes only a single *.nib file as input. The file contains everything required to build a native executable (or a native shared library). This can be useful when large applications consisting of many input files (JAR files, configuration files, auto-generated files, downloaded files) need to be rebuilt at a later point in time without worrying whether all files are still available. Often complex builds involve downloading many libraries that are not guaranteed to remain accessible later in time. Using Native Image bundles is a safe solution to encapsulate all this input required for building into a single file.</p> <p>Note: The feature is experimental.</p>"},{"location":"#table-of-contents_2","title":"Table of Contents","text":"<ul> <li>Creating Bundles</li> <li>Building with Bundles</li> <li>Environment Variables</li> <li>Creating New Bundles from Existing Bundles</li> <li>Bundle File Format</li> </ul>"},{"location":"#creating-bundles","title":"Creating Bundles","text":"<p>To create a bundle, pass the <code>--bundle-create</code> option along with the other arguments for a specific <code>native-image</code> command line invocation. This will cause <code>native-image</code> to create a *.nib file in addition to the actual image.</p> <p>Here is the option description:</p> <pre><code>--bundle-create[=new-bundle.nib]\n                      in addition to image building, create a Native Image bundle file (*.nib\n                      file) that allows rebuilding of that image again at a later point. If a\n                      bundle-file gets passed, the bundle will be created with the given\n                      name. Otherwise, the bundle-file name is derived from the image name.\n                      Note both bundle options can be combined with --dry-run to only perform\n                      the bundle operations without any actual image building.\n</code></pre> <p>For example, assuming a Micronaut application is built with Maven, make sure the <code>--bundle-create</code> option is used. For that, the following needs to be added to the plugins section of <code>pom.xml</code>:</p> <pre><code>&lt;plugin&gt;\n  &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;\n  &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;\n  &lt;configuration&gt;\n      &lt;buildArgs combine.children=\"append\"&gt;\n          &lt;buildArg&gt;--bundle-create&lt;/buildArg&gt;\n      &lt;/buildArgs&gt;\n  &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Then, when you run the Maven package command <code>./mvnw package -Dpackaging=native-image</code>, you will get the following build artifacts:</p> <pre><code>Finished generating 'micronautguide' in 2m 0s.\n\nNative Image Bundles: Bundle build output written to /home/testuser/micronaut-data-jdbc-repository-maven-java/target/micronautguide.output\nNative Image Bundles: Bundle written to /home/testuser/micronaut-data-jdbc-repository-maven-java/target/micronautguide.nib\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  02:08 min\n[INFO] Finished at: 2023-03-27T15:09:36+02:00\n[INFO] ------------------------------------------------------------------------\n</code></pre> <p>This output indicates that you have created a native executable, <code>micronautguide</code>, and a bundle, micronautguide.nib. The bundle file is created in the target/ directory. It should be copied to some safe place where it can be found if the native executable needs to be rebuilt later.</p> <p>Obviously, a bundle file can be large because it contains all input files as well as the executable itself (the executable is compressed within the bundle).  Having the image inside the bundle allows comparing a native executable rebuilt from the bundle against the original one. In the case of the <code>micronaut-data-jdbc-repository</code> example, the bundle is 60.7 MB (the executable is 103.4 MB). To see what is inside a bundle, run <code>jar tf *.nib</code>:</p> <pre><code>$ jar tf micronautguide.nib\nMETA-INF/MANIFEST.MF\nMETA-INF/nibundle.properties\noutput/default/micronautguide\ninput/classes/cp/micronaut-core-3.8.7.jar\ninput/classes/cp/netty-buffer-4.1.87.Final.jar\ninput/classes/cp/jackson-databind-2.14.1.jar\ninput/classes/cp/micronaut-context-3.8.7.jar\ninput/classes/cp/reactive-streams-1.0.4.jar\n...\ninput/classes/cp/netty-handler-4.1.87.Final.jar\ninput/classes/cp/micronaut-jdbc-4.7.2.jar\ninput/classes/cp/jackson-core-2.14.0.jar\ninput/classes/cp/micronaut-runtime-3.8.7.jar\ninput/classes/cp/micronautguide-0.1.jar\ninput/stage/build.json\ninput/stage/environment.json\ninput/stage/path_substitutions.json\ninput/stage/path_canonicalizations.json\n</code></pre> <p>As you can see, a bundle is just a JAR file with a specific layout. This is explained in detail below.</p> <p>Next to the bundle, you can also find the output directory: target/micronautguide.output. It contains the native executable and all other files that were created as part of the build.  Since you did not specify any options that would produce extra output (for example, <code>-g</code> to generate debugging information or <code>--diagnostics-mode</code>), only the executable can be found there:</p> <pre><code>$ tree target/micronautguide.output\ntarget/micronautguide.output\n\u251c\u2500\u2500 default\n\u2502   \u2514\u2500\u2500 micronautguide\n\u2514\u2500\u2500 other\n</code></pre>"},{"location":"#combining-bundle-create-with-dry-run","title":"Combining --bundle-create with --dry-run","text":"<p>As mentioned in the <code>--bundle-create</code> option description, it is also possible to let <code>native-image</code> build a bundle but not actually perform the image building. This might be useful if a user wants to move the bundle to a more powerful machine and build the image there. Modify the above <code>native-maven-plugin</code> configuration to also contain the argument <code>&lt;buildArg&gt;--dry-run&lt;/buildArg&gt;</code>.  Then running <code>./mvnw package -Dpackaging=native-image</code> takes only seconds and the created bundle is much smaller: </p> <pre><code>Native Image Bundles: Bundle written to /home/testuser/micronaut-data-jdbc-repository-maven-java/target/micronautguide.nib\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  2.267 s\n[INFO] Finished at: 2023-03-27T16:33:21+02:00\n[INFO] ------------------------------------------------------------------------\n</code></pre> <p>Now micronautguide.nib is only 20 MB in file size and the executable is not included:</p> <pre><code>$ jar tf micronautguide.nib\nMETA-INF/MANIFEST.MF\nMETA-INF/nibundle.properties\ninput/classes/cp/micronaut-core-3.8.7.jar\n...\n</code></pre> <p>Note that this time you do not see the following message in the Maven output:</p> <pre><code>Native Image Bundles: Bundle build output written to /home/testuser/micronaut-data-jdbc-repository-maven-java/target/micronautguide.output\n</code></pre> <p>Since no executable is created, no bundle build output is available.</p>"},{"location":"#building-with-bundles","title":"Building with Bundles","text":"<p>Assuming that the native executable is used in production and once in a while an unexpected exception is thrown at run time. Since you still have the bundle that was used to create the executable, it is trivial to build a variant of that executable with debugging support. Use <code>--bundle-apply=micronautguide.nib</code> like this:</p> <pre><code>$ native-image --bundle-apply=micronautguide.nib -g\n\nNative Image Bundles: Loaded Bundle from /home/testuser/micronautguide.nib\nNative Image Bundles: Bundle created at 'Tuesday, March 28, 2023, 11:12:04 AM Central European Summer Time'\nNative Image Bundles: Using version: '20.0.1+8' (vendor 'Oracle Corporation') on platform: 'linux-amd64'\nWarning: Native Image Bundles are an experimental feature.\n========================================================================================================================\nGraalVM Native Image: Generating 'micronautguide' (executable)...\n========================================================================================================================\n...\nFinished generating 'micronautguide' in 2m 16s.\n\nNative Image Bundles: Bundle build output written to /home/testuser/micronautguide.output\n</code></pre> <p>After running this command, the executable is rebuilt with an extra option <code>-g</code> passed after <code>--bundle-apply</code>. The output of this build is in the directory micronautguide.output:</p> <pre><code>micronautguide.output\nmicronautguide.output/other\nmicronautguide.output/default\nmicronautguide.output/default/micronautguide.debug\nmicronautguide.output/default/micronautguide\nmicronautguide.output/default/sources\nmicronautguide.output/default/sources/javax\nmicronautguide.output/default/sources/javax/smartcardio\nmicronautguide.output/default/sources/javax/smartcardio/TerminalFactory.java\n...\nmicronautguide.output/default/sources/java/lang/Object.java\n</code></pre> <p>You successfully rebuilt the application from the bundle with debug info enabled.</p> <p>The full option help of <code>--bundle-apply</code> shows a more advanced use case that will be discussed later in detail:</p> <pre><code>--bundle-apply=some-bundle.nib\n                      an image will be built from the given bundle file with the exact same\n                      arguments and files that have been passed to native-image originally\n                      to create the bundle. Note that if an extra --bundle-create gets passed\n                      after --bundle-apply, a new bundle will be written based on the given\n                      bundle args plus any additional arguments that haven been passed\n                      afterwards. For example:\n                      &gt; native-image --bundle-apply=app.nib --bundle-create=app_dbg.nib -g\n                      creates a new bundle app_dbg.nib based on the given app.nib bundle.\n                      Both bundles are the same except the new one also uses the -g option.\n</code></pre>"},{"location":"#capturing-environment-variables","title":"Capturing Environment Variables","text":"<p>Before bundle support was added, all environment variables were visible to the  <code>native-image</code> builder. This approach does not work well with bundles and is problematic for image building without bundles. Consider having an environment variable that holds sensitive information from your build machine. Due to Native Image's ability to run code at build time that can create data to be available at run time, it is very easy to build an image were you accidentally leak the contents of such variables.</p> <p>Passing environment variables to <code>native-image</code> now requires explicit arguments.</p> <p>Suppose a user wants to use an environment variable (for example, <code>KEY_STORAGE_PATH</code>) from the environment in which the <code>native-image</code> tool is invoked, in the class initializer that is set to be initialized at build time. To allow accessing the variable in the class initializer (with <code>java.lang.System.getenv</code>), pass the option <code>-EKEY_STORAGE_PATH</code> to the builder.</p> <p>To make an environment variable accessible to build time, use:</p> <pre><code>-E&lt;env-var-key&gt;[=&lt;env-var-value&gt;]\n                      allow native-image to access the given environment variable during\n                      image build. If the optional &lt;env-var-value&gt; is not given, the value\n                      of the environment variable will be taken from the environment\n                      native-image was invoked from.\n</code></pre> <p>Using <code>-E</code> works as expected with bundles. Any environment variable specified with <code>-E</code> will be captured in the bundle. For variables where the optional <code>&lt;env-var-value&gt;</code> is not given, the bundle would capture the value the variable had at the time the bundle was created. The prefix <code>-E</code> was chosen to make the option look similar to the related <code>-D&lt;java-system-property-key&gt;=&lt;java-system-property-value&gt;</code> option (which makes Java system properties available at build time).</p>"},{"location":"#combining-bundle-create-and-bundle-apply","title":"Combining --bundle-create and --bundle-apply","text":"<p>As already mentioned in Building with Bundles, it is possible to create a new bundle based on an existing one. The <code>--bundle-apply</code> help message has a simple example. A more interesting example arises if an existing bundle is used to create a new bundle that builds a PGO-optimized version of the original application.</p> <p>Assuming you have already built the <code>micronaut-data-jdbc-repository</code> example into a bundle named micronautguide.nib. To produce a PGO-optimized variant of that bundle, first build a variant of the native executable that generates PGO profiling information at run time (you will use it later):</p> <pre><code>$ native-image --bundle-apply=micronautguide.nib --pgo-instrument\n</code></pre> <p>Now run the generated executable so that profile information is collected:</p> <pre><code>$ /home/testuser/micronautguide.output/default/micronautguide\n</code></pre> <p>Based on this walkthrough, you use the running native executable to add new database entries and query the information in the database afterwards so that you get real-world profiling information. Once completed, stop the Micronaut application using <code>Ctrl+C</code> (<code>SIGTERM</code>). Looking into the current working directory, you can find a new file:</p> <pre><code>$ ls -lh  *.iprof\n-rw------- 1 testuser testuser 19M Mar 28 14:52 default.iprof\n</code></pre> <p>The file <code>default.iprof</code> contains the profiling information that was created because you ran the Micronaut application from the executable built with <code>--pgo-instrument</code>. Now you can create a new optimized bundle out of the existing one:</p> <pre><code>native-image --bundle-apply=micronautguide.nib --bundle-create=micronautguide-pgo-optimized.nib --dry-run --pgo\n</code></pre> <p>Now take a look how micronautguide-pgo-optimized.nib is different from micronautguide.nib:</p> <pre><code>$ ls -lh *.nib\n-rw-r--r-- 1 testuser testuser  20M Mar 28 11:12 micronautguide.nib\n-rw-r--r-- 1 testuser testuser  23M Mar 28 15:02 micronautguide-pgo-optimized.nib\n</code></pre> <p>You can see that the new bundle is 3 MB larger than the original. The reason, as can be guessed, is that now the bundle contains the default.iprof file. Using a tool to compare directories, you can inspect the differences in detail:</p> <p></p> <p>As you can see, micronautguide-pgo-optimized.nib contains default.iprof in the directory input/auxiliary, and there are also changes in other files. The contents of META-INF/nibundle.properties, input/stage/path_substitutions.json and input/stage/path_canonicalizations.json will be explained later.  For now, look at the diff in build.json:</p> <pre><code>@@ -4,5 +4,6 @@\n   \"--no-fallback\",\n   \"-H:Name=micronautguide\",\n   \"-H:Class=example.micronaut.Application\",\n-  \"--no-fallback\"\n+  \"--no-fallback\",\n+  \"--pgo\"\n ]\n</code></pre> <p>As expected, the new bundle contains the <code>--pgo</code> option that you passed to <code>native-image</code> to build an optimized bundle. Building a native executable from this new bundle generates a PGO-optimized executable out of the box (see <code>PGO: on</code> in build output):</p> <pre><code>$ native-image --bundle-apply=micronautguide-pgo-optimized.nib\n...\n[1/8] Initializing...                                                                                    (3.9s @ 0.27GB)\n Java version: 20.0.1+8, vendor version: GraalVM EE 20.0.1+8.1\n Graal compiler: optimization level: '2', target machine: 'x86-64-v3', PGO: on\n C compiler: gcc (redhat, x86_64, 13.0.1)\n Garbage collector: Serial GC (max heap size: 80% of RAM)\n 6 user-specific feature(s)\n...\n</code></pre>"},{"location":"#bundle-file-format","title":"Bundle File Format","text":"<p>A bundle file is a JAR file with a well-defined internal layout. Inside a bundle you can find the following inner structure:</p> <pre><code>[bundle-file.nib]\n\u251c\u2500\u2500 META-INF\n\u2502   \u251c\u2500\u2500 MANIFEST.MF\n\u2502   \u2514\u2500\u2500 nibundle.properties &lt;- Contains build bundle version info:\n\u2502                              * Bundle format version (BundleFileVersion{Major,Minor})\n\u2502                              * Platform and architecture the bundle was created on \n\u2502                              * GraalVM / Native-image version used for bundle creation\n\u251c\u2500\u2500 input &lt;- All information required to rebuild the image\n\u2502   \u251c\u2500\u2500 auxiliary &lt;- Contains auxiliary files passed to native-image via arguments\n\u2502   \u2502                (e.g. external `config-*.json` files or PGO `*.iprof`-files)\n\u2502   \u251c\u2500\u2500 classes   &lt;- Contains all class-path and module-path entries passed to the builder\n\u2502   \u2502   \u251c\u2500\u2500 cp\n\u2502   \u2502   \u2514\u2500\u2500 p\n\u2502   \u2514\u2500\u2500 stage\n\u2502       \u251c\u2500\u2500 build.json          &lt;- Full native-image command line (minus --bundle options)\n\u2502       \u251c\u2500\u2500 environment.json              &lt;- Environment variables used in the image build\n\u2502       \u251c\u2500\u2500 path_canonicalizations.json  &lt;- Record of path-canonicalizations that happened\n\u2502       \u2502                                       during bundle creation for the input files  \n\u2502       \u2514\u2500\u2500 path_substitutions.json          &lt;- Record of path-substitutions that happened\n\u2502                                               during bundle creation for the input files\n\u2514\u2500\u2500 output\n    \u251c\u2500\u2500 default\n    \u2502   \u251c\u2500\u2500 myimage         &lt;- Created image and other output created by the image builder \n    \u2502   \u251c\u2500\u2500 myimage.debug\n    |   \u2514\u2500\u2500 sources\n    \u2514\u2500\u2500 other      &lt;- Other output created by the builder (not relative to image location)\n</code></pre>"},{"location":"#meta-inf","title":"META-INF","text":"<p>The layout of a bundle file itself is versioned. There are two properties in META-INF/nibundle.properties that declare which version of the layout a given bundle file is based on. Bundles currently use the following layout version:</p> <pre><code>BundleFileVersionMajor=0\nBundleFileVersionMinor=9\n</code></pre> <p>Future versions of GraalVM might alter or extend the internal structure of bundle files. The versioning enables us to evolve the bundle format with backwards compatibility in mind.</p>"},{"location":"#input","title":"input","text":"<p>This directory contains all input data that gets passed to the <code>native-image</code> builder.  The file input/stage/build.json holds the original command line that was passed to <code>native-image</code> when the bundle was created.</p> <p>Parameters that make no sense to get reapplied in a bundle-build are already filtered out. These include: * <code>--bundle-{create,apply}</code> * <code>--verbose</code> * <code>--dry-run</code></p> <p>The state of environment variables that are relevant for the build are captured in input/stage/environment.json. For every <code>-E</code> argument that were seen when the bundle was created, a snapshot of its key-value pair is recorded in the file. The remaining files path_canonicalizations.json and path_substitutions.json contain a record of the file-path transformations that were performed by the <code>native-image</code> tool based on the input file paths as specified by the original command line arguments.</p>"},{"location":"#output","title":"output","text":"<p>If a native executable is built as part of building the bundle (for example, the <code>--dry-run</code> option was not used), you also have an output directory in the bundle. It contains the executable that was built along with any other files that were generated as part of building. Most output files are located in the directory output/default (the executable, its debug info, and debug sources). Builder output files, that would have been written to arbitrary absolute paths if the executable had not been built in the bundle mode, can be found in output/other.</p>"},{"location":"#related-documentation_2","title":"Related Documentation","text":"<ul> <li>Native Image Build Configuration</li> <li>Native Image Build Output</li> </ul>"},{"location":"#native-image-c-api","title":"Native Image C API","text":"<p>Native Image provides a GraalVM-specific API to manage Java objects from the C/C++ languages, initialize isolates and attach threads. The C API is available when Native Image is built as a shared library and its declarations are included in the header file that is generated during the native image build.</p> <pre><code>/*\n * Structure representing an isolate. A pointer to such a structure can be\n * passed to an entry point as the execution context.\n */\nstruct __graal_isolate_t;\ntypedef struct _graal_isolate_t graal_isolate_t;\n\n/*\n * Structure representing a thread that is attached to an isolate. A pointer to\n * such a structure can be passed to an entry point as the execution context,\n * requiring that the calling thread has been attached to that isolate.\n */\nstruct __graal_isolatethread_t;\ntypedef struct __graal_isolatethread_t graal_isolatethread_t;\n\n/* Parameters for the creation of a new isolate. */\nstruct __graal_create_isolate_params_t {\n    /* for future use */\n};\ntypedef struct __graal_create_isolate_params_t graal_create_isolate_params_t;\n\n/*\n * Create a new isolate, considering the passed parameters (which may be NULL).\n * Returns 0 on success, or a non-zero value on failure.\n * On success, the current thread is attached to the created isolate, and the\n * address of the isolate and the isolate thread structures is written to the\n * passed pointers if they are not NULL.\n */\nint graal_create_isolate(graal_create_isolate_params_t* params, graal_isolate_t** isolate, graal_isolatethread_t** thread);\n\n/*\n * Attaches the current thread to the passed isolate.\n * On failure, returns a non-zero value. On success, writes the address of the\n * created isolate thread structure to the passed pointer and returns 0.\n * If the thread has already been attached, the call succeeds and also provides\n * the thread's isolate thread structure.\n */\nint graal_attach_thread(graal_isolate_t* isolate, graal_isolatethread_t** thread);\n\n/*\n * Given an isolate to which the current thread is attached, returns the address of\n * the thread's associated isolate thread structure.  If the current thread is not\n * attached to the passed isolate or if another error occurs, returns NULL.\n */\ngraal_isolatethread_t* graal_get_current_thread(graal_isolate_t* isolate);\n\n/*\n * Given an isolate thread structure, determines to which isolate it belongs and\n * returns the address of its isolate structure. If an error occurs, returns NULL\n * instead.\n */\ngraal_isolate_t* graal_get_isolate(graal_isolatethread_t* thread);\n\n/*\n * Detaches the passed isolate thread from its isolate and discards any state or\n * context that is associated with it. At the time of the call, no code may still\n * be executing in the isolate thread's context.\n * Returns 0 on success, or a non-zero value on failure.\n */\nint graal_detach_thread(graal_isolatethread_t* thread);\n\n/*\n * Tears down the isolate of the passed (and still attached) isolate thread\n * waiting for any attached threads to detach from it, then discards its objects,\n * threads, and any other state or context that is associated with it.\n * Returns 0 on success, or a non-zero value on failure.\n */\nint graal_tear_down_isolate(graal_isolatethread_t* thread);\n</code></pre> <p>In addition to the C level API, you can use the JNI Invocation API to create an isolate from Java, expose and call Java methods embedded in a native shared library.</p>"},{"location":"#related-documentation_3","title":"Related Documentation","text":"<ul> <li>Build a Native Shared Library</li> <li>Interoperability with Native Code</li> <li>JNI Invocation API</li> </ul>"},{"location":"#certificate-management-in-native-image","title":"Certificate Management in Native Image","text":"<p>Native Image provides multiple ways to specify the certificate file used to define the default TrustStore. In the following sections we describe the available build-time and run-time options. Note: The default behavior for <code>native-image</code> is to capture and use the default TrustStore from the build-time host environment.</p>"},{"location":"#build-time-options","title":"Build-time Options","text":"<p>During the image building process, the <code>native-image</code> builder captures the host environment's default TrustStore and embeds it into the native executable. This TrustStore is by default created from the root certificate file provided within the JDK, but can be changed to use a different certificate file by setting the build-time system property <code>javax.net.ssl.trustStore</code> (see Properties for how to do it).</p> <p>Since the contents of the build-time certificate file is embedded into the native executable, the file itself does not need to be present in the target environment.</p>"},{"location":"#runtime-options","title":"Runtime Options","text":"<p>The certificate file can also be changed dynamically at run time via setting the <code>javax.net.ssl.trustStore\\*</code> system properties.</p> <p>If any of the following system properties are set during the image execution, <code>native-image</code> also requires <code>javax.net.ssl.trustStore</code> to be set, and for it to point to an accessible certificate file: - <code>javax.net.ssl.trustStore</code> - <code>javax.net.ssl.trustStoreType</code> - <code>javax.net.ssl.trustStoreProvider</code> - <code>javax.net.ssl.trustStorePassword</code></p> <p>If any of these properties are set and <code>javax.net.ssl.trustStore</code> does not point to an accessible file, then an <code>UnsupportedFeatureError</code> will be thrown.</p> <p>Note that this behavior is different than OpenJDK. When the <code>javax.net.ssl.trustStore</code> system property is unset or invalid, OpenJDK will fallback to using a certificate file shipped within the JDK. However, such files will not be present alongside the image executable and hence cannot be used as a fallback.</p> <p>During the execution, it also possible to dynamically change the <code>javax.net.ssl.trustStore\\*</code> properties and for the default TrustStore to be updated accordingly.</p> <p>Finally, whenever all of the <code>javax.net.ssl.trustStore\\*</code> system properties listed above are unset, the default TrustStore will be the one captured during the build time, as described in the prior section.</p>"},{"location":"#untrusted-certificates","title":"Untrusted Certificates","text":"<p>During the image building process, a list of untrusted certificates is loaded from the file <code>&lt;java.home&gt;/lib/security/blacklisted.certs</code>. This file is used when validating certificates at both build time and run time. In other words, when a new certificate file is specified at run time via setting the <code>javax.net.ssl.trustStore\\*</code> system properties, the new certificates will still be checked against the <code>&lt;java.home&gt;/lib/security/blacklisted.certs</code> loaded at image build time.</p>"},{"location":"#class-initialization-in-native-image","title":"Class Initialization in Native Image","text":"<p>The semantics of Java requires that a class is initialized the first time it is accessed at runtime. Class initialization has negative consequences for compiling Java applications ahead-of-time for the following two reasons:</p> <ul> <li>It significantly degrades the performance of a native executable: every access to a class (via a field or method) requires a check to ensure the class is already initialized. Without optimization, this can reduce performance by more than twofold.</li> <li>It increases the amount of computation--and time--to startup an application. For example, the simple \"Hello, World!\" application requires more than 300 classes to be initialized.</li> </ul> <p>To reduce the negative impact of class initialization, Native Image supports class initialization at build time: it can initialize classes when it builds an executable, making runtime initialization and checks unnecessary. All the static state from initialized classes is stored in the executable. Access to a class's static fields that were initialized at build time is transparent to the application and works as if the class was initialized at runtime.</p> <p>However, Java class initialization semantics impose several constraints that complicate class initialization policies, such as:</p> <ul> <li> <p>When a class is initialized, all its superclasses and superinterfaces with default methods must also be initialized. Interfaces without default methods, however, are not initialized. To accommodate this requirement, a short-term \"relevant supertype\" is used, as well as a \"relevant subtype\" for subtypes of classes and interfaces with default methods.</p> </li> <li> <p>Relevant supertypes of types initialized at build time must also be initialized at build time.</p> </li> <li>Relevant subtypes of types initialized at runtime must also be initialized at runtime.</li> <li>No instances of classes that are initialized at runtime must be present in the executable.</li> </ul> <p>To enjoy the complete out-of-the-box experience of Native Image and still get the benefits of build-time initialization, Native Image does two things:</p> <ul> <li>Build-Time Initialization</li> <li>Automatic Initialization of Safe Classes</li> </ul> <p>To track which classes were initialized and why, pass the command-line option <code>-H:+PrintClassInitialization</code> to the <code>native-image</code> tool. This option helps you configure the <code>native image</code> builder to work as required. The goal is to have as many classes as possible initialized at build time, yet keep the correct semantics of the application.</p>"},{"location":"#build-time-initialization","title":"Build-Time Initialization","text":"<p>Native Image initializes most JDK classes at build time, including the garbage collector, important JDK classes, and the deoptimizer. For all of the classes that are initialized at build time, Native Image gives proper support so that the semantics remain consistent despite class initialization occurring at build time. If you discover an issue with a JDK class behaving incorrectly because of class initialization at build time, please report an issue.</p>"},{"location":"#automatic-initialization-of-safe-classes","title":"Automatic Initialization of Safe Classes","text":"<p>For application classes, Native Image tries to find classes that can be safely initialized at build time. A class is considered safe if all of its relevant supertypes are safe and if the class initializer does not call any unsafe methods or initialize other unsafe classes.</p> <p>A method is considered unsafe if:</p> <ul> <li>It transitively calls into native code (such as <code>System.out.println</code>): native code is not analyzed so Native Image cannot know if illegal actions are performed.</li> <li>It calls a method that cannot be reduced to a single target (a virtual method). This restriction avoids the explosion of search space for the safety analysis of static initializers.</li> <li>It is substituted by Native Image. Running initializers of substituted methods would yield different results in the hosting Java virtual machine (VM) than in the produced executable. As a result, the safety analysis would consider some methods safe but calling them would lead to illegal states.</li> </ul> <p>A test that shows examples of classes that are proven safe can be found here. The list of all classes that are proven safe is output to a file via the <code>-H:+PrintClassInitialization</code> command-line option to the <code>native-image</code> tool.</p> <p>Note: You can also Specify Class Initialization Explicitly.</p>"},{"location":"#related-documentation_4","title":"Related Documentation","text":"<ul> <li>Native Image Basics</li> <li>Native Image Compatibility Guide</li> <li>Specify Class Initialization Explicitly</li> </ul>"},{"location":"#native-image-compatibility-guide","title":"Native Image Compatibility Guide","text":"<p>Native Image uses a different way of compiling a Java application than the traditional Java virtual machine (VM). It distinguishes between build time and run time. At the image build time, the <code>native-image</code> builder performs static analysis to find all the methods that are reachable from the entry point of an application. The builder then compiles these (and only these) methods into an executable binary. Because of this different compilation model, a Java application can behave somewhat differently when compiled into a native image.</p> <p>Native Image provides an optimization to reduce the memory footprint and startup time of an application. This approach relies on a \"closed-world assumption\" in which all code is known at build time. That is, no new code is loaded at run time. As with most optimizations, not all applications are amenable to this approach. If the <code>native-image</code> builder is unable to optimize an application at build time, it generates a so-called \"fallback file\" that requires a Java VM to run. We recommend to check Native Image Basics for a detailed description what happens with your Java application at build and run times.</p>"},{"location":"#features-requiring-metadata","title":"Features Requiring Metadata","text":"<p>To be suitable for closed-world assumption, the following Java features generally require metadata to pass to <code>native-image</code> at build time.  This metadata ensures that a native image uses the minimum amount of space necessary.</p> <p>The compatibility of Native Image with the most popular Java libraries was recently enhanced by publishing shared reachability metadata on GitHub. The users can share the burden of maintaining metadata for third-party dependencies and reuse it. See Reachability Metadata to learn more.</p>"},{"location":"#features-incompatible-with-closed-world-assumption","title":"Features Incompatible with Closed-World Assumption","text":"<p>Some Java features are not yet supported within the closed-world assumption, and if used, result in a fallback file.</p>"},{"location":"#invokedynamic-bytecode-and-method-handles","title":"<code>invokedynamic</code> Bytecode and Method Handles","text":"<p>Under the closed-world assumption, all methods that are called and their call sites must be known. The <code>invokedynamic</code>method and method handles can introduce calls at run time or change the method that is invoked.</p> <p>Note that <code>invokedynamic</code> use cases generated by <code>javac</code> for, for example, Java lambda expressions and String concatenation that are supported because they do not change called methods at run time.</p>"},{"location":"#security-manager","title":"Security Manager","text":"<p>Native Image will not allow a Java Security Manager to be enabled because this functionality has deprecated since Java 17.</p>"},{"location":"#features-that-may-operate-differently-in-a-native-image","title":"Features That May Operate Differently in a Native Image","text":"<p>Native Image implements some Java features differently to the Java VM.</p>"},{"location":"#signal-handlers","title":"Signal Handlers","text":"<p>Registering a signal handler requires a new thread to start that handles the signal and invokes shutdown hooks. By default, no signal handlers are registered when building a native image, unless they are registered explicitly by the user. For example, it is not recommended to register the default signal handlers when building a shared library, but it is desirable to include signal handlers when building a native executable for containerized environments, such as Docker containers.</p> <p>To register the default signal handlers, pass the <code>--install-exit-handlers</code> option to the <code>native-image</code> builder. This option gives you the same signal handlers as a Java VM.</p>"},{"location":"#class-initializers","title":"Class Initializers","text":"<p>By default, classes are initialized at run time. This ensures compatibility, but limits some optimizations. For faster startup and better peak performance, it is better to initialize classes at build time. Class initialization behavior can be specified using the options\u00a0<code>--initialize-at-build-time</code>\u00a0or\u00a0<code>--initialize-at-run-time</code>\u00a0for specific classes and packages or for all classes. Classes that are members of the JDK class libraries are initialized by default.</p> <p>Note: Class initialization at build time may break specific assumptions in existing code. For example, files loaded in a class initializer may not be in the same place at build time as at run time. Also, certain objects such as a file descriptors or running threads must not be stored in a native executable. If such objects are reachable at build time, the <code>native image</code> builder fails with an error.</p> <p>For more information, see Class Initialization in Native Image.</p>"},{"location":"#finalizers","title":"Finalizers","text":"<p>The Java base class <code>java.lang.Object</code> defines the method <code>finalize()</code>. It is called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass can override the <code>finalize()</code> method to dispose of system resources or to perform other cleanup operations.</p> <p>Finalizers have been deprecated since Java SE 9. They are complicated to implement, and have badly designed semantics. For example, a finalizer can cause an object to be reachable again by storing a reference to it in a static field. Therefore, finalizers are not invoked. We recommend you replace finalizers with weak references and reference queues.</p>"},{"location":"#threads","title":"Threads","text":"<p>Native Image does not implement long-deprecated methods in <code>java.lang.Thread</code> such as <code>Thread.stop()</code>.</p>"},{"location":"#unsafe-memory-access","title":"Unsafe Memory Access","text":"<p>Fields that are accessed using <code>sun.misc.Unsafe</code> need to be marked as such for the static analysis if classes are initialized at build time. In most cases, that happens automatically: field offsets stored in <code>static final</code> fields are automatically rewritten from the hosted value (the field offset for the Java VM on which the <code>native image</code> builder is running) to the native executable value, and as part of that rewrite the field is marked as <code>Unsafe</code>-accessed. For non-standard patterns, field offsets can be recomputed manually using the annotation <code>RecomputeFieldValue</code>.</p>"},{"location":"#debugging-and-monitoring","title":"Debugging and Monitoring","text":"<p>Java has some optional specifications that a Java implementation can use for debugging and monitoring Java programs, including JVMTI. They help you monitor the Java VM at runtime for events such as compilation, for example, which do not occur in most native images. These interfaces are built on the assumption that Java bytecodes are available at run time, which is not the case for native images built with the closed-world optimization. Because the <code>native-image</code> builder generates a native executable, users must use native debuggers and monitoring tools (such as GDB or VTune) rather than tools targeted for Java. JVMTI and other bytecode-based tools are not supported with Native Image.</p>"},{"location":"#limitations-on-linux-aarch64-architecture","title":"Limitations on Linux AArch64 Architecture","text":"<p>Mostly all Native Image features are supported on Linux AArch64 architecture, except for the limitations described below.</p> <ul> <li><code>-R:[+|-]WriteableCodeCache</code>: must be disabled.</li> <li><code>--libc=&lt;value&gt;</code>: <code>musl</code> is not supported.</li> <li><code>--gc=&lt;value&gt;</code>: The G1 garbage collector (<code>G1</code>) is not supported.</li> </ul> <p>Find a complete list of options to the <code>native-image</code> builder here.</p>"},{"location":"#related-documentation_5","title":"Related Documentation","text":"<ul> <li>Class Initialization in Native Image</li> <li>Reachability Metadata</li> <li>GraalVM Reachability Metadata Repository</li> </ul>"},{"location":"#debug-info-feature","title":"Debug Info Feature","text":"<p>To add debug information to a generated native image, provide the <code>-g</code> option to the <code>native-image</code> builder:</p> <pre><code>native-image -g Hello\n</code></pre> <p>The <code>-g</code> flag instructs <code>native-image</code> to generate debug information. The resulting image will contain debug records in a format the GNU Debugger (GDB) understands. Additionally, you can pass <code>-O0</code> to the builder which specifies that no compiler optimizations should be performed. Disabling all optimizations is not required, but in general it makes the debugging experience better.</p> <p>Debug information is not just useful to the debugger. It can also be used by the Linux performance profiling tools <code>perf</code> and <code>valgrind</code> to correlate execution statistics such as CPU utilization or cache misses with specific, named Java methods and even link them to individual lines of Java code in the original Java source file.</p> <p>By default, debug info will only include details of some of the values of parameters and local variables. This means that the debugger will report many parameters and local variables as being undefined. If you pass <code>-O0</code> to the builder then full debug information will be included. If you want more parameter and local variable information to be included when employing higher levels of optimization (<code>-O1</code> or, the default, <code>-O2</code>) you need to pass an extra command line flag to the <code>native-image</code> command</p> <pre><code>native-image -g -H:+SourceLevelDebug Hello\n</code></pre> <p>Enabling debuginfo with flag <code>-g</code> does not make any difference to how a generated native image is compiled and does not affect how fast it executes nor how much memory it uses at runtime. However, it can significantly increase the size of the generated image on disk. Enabling full parameter and local variable information by passing flag <code>-H:+SourceLevelDebug</code> can cause a program to be compiled slightly differently and for some applications this can slow down execution.</p> <p>The basic <code>perf report</code> command, which displays a histogram showing percentage execution time in each Java method, only requires passing flags <code>-g</code> and <code>-H:+SourceLevelDebug</code> to the <code>native-image</code> command. However, more sophisticated uses of <code>perf</code> (i.e. <code>perf annotate</code>) and use of <code>valgrind</code> requires debug info to be supplemented with linkage symbols identifying compiled Java methods. Java method symbols are omitted from the generated native image by default but they can be retained achieved by passing one extra flag to the <code>native-image</code> command</p> <pre><code>native-image -g -H:+SourceLevelDebug -H:-DeleteLocalSymbols Hello\n</code></pre> <p>Use of this flag will result in a small increase in the size of the resulting image file.</p> <p>Note: Native Image debugging currently works on Linux with initial support for macOS. The feature is experimental.</p> <p>Note: Debug info support for <code>perf</code> and <code>valgrind</code> on Linux is an experimental feature.</p>"},{"location":"#table-of-contents_3","title":"Table of Contents","text":"<ul> <li>Source File Caching</li> <li>Special Considerations for Debugging Java from GDB</li> <li>Identifying Source Code Location</li> <li>Configuring Source Paths in GNU Debugger</li> <li>Checking Debug Info on Linux</li> <li>Debugging with Isolates</li> <li>Debugging Helper Methods</li> <li>Special Considerations for using perf and valgrind</li> </ul>"},{"location":"#source-file-caching","title":"Source File Caching","text":"<p>The <code>-g</code> option also enables caching of sources for any JDK runtime classes, GraalVM classes, and application classes which can be located when generating a native executable. By default, the cache is created alongside the generated binary in a subdirectory named <code>sources</code>. If a target directory for the native executable is specified using option <code>-H:Path=...</code> then the cache is also relocated under that same target.  Use a command line option to provide an alternative path to <code>sources</code> and to configure source file search path roots for the debugger. Files in the cache are located in a directory hierarchy that matches the file path information included in the debug records of the native executable. The source cache should contain all the files needed to debug the generated binary and nothing more. This local cache provides a convenient way of making just the necessary sources available to the debugger or IDE when debugging a native executable.</p> <p>The implementation tries to be smart about locating source files. It uses the current <code>JAVA_HOME</code> to locate the JDK src.zip when searching for JDK runtime sources. It also uses entries in the classpath to suggest locations for GraalVM source files and application source files (see below for precise details of the scheme used to identify source locations). However, source layouts do vary and it may not be possible to find all sources. Hence, users can specify the location of source files explicitly on the command line using option <code>DebugInfoSourceSearchPath</code>:</p> <pre><code>javac --source-path apps/greeter/src \\\n    -d apps/greeter/classes org/my/greeter/*Greeter.java\njavac -cp apps/greeter/classes \\\n    --source-path apps/hello/src \\\n    -d apps/hello/classes org/my/hello/Hello.java\nnative-image -g \\\n    -H:-SpawnIsolates \\\n    -H:DebugInfoSourceSearchPath=apps/hello/src \\\n    -H:DebugInfoSourceSearchPath=apps/greeter/src \\\n    -cp apps/hello/classes:apps/greeter/classes org.my.hello.Hello\n</code></pre> <p>The <code>DebugInfoSourceSearchPath</code> option can be repeated as many times as required to notify all the target source locations. The value passed to this option can be either an absolute or relative path. It can identify either a directory, a source JAR, or a source ZIP file. It is also possible to specify several source roots at once using a comma separator:</p> <pre><code>native-image -g \\\n    -H:DebugInfoSourceSearchPath=apps/hello/target/hello-sources.jar,apps/greeter/target/greeter-sources.jar \\\n    -cp apps/target/hello.jar:apps/target/greeter.jar \\\n    org.my.Hello\n</code></pre> <p>By default, the cache of application, GraalVM, and JDK sources is created in a directory named <code>sources</code>. The <code>DebugInfoSourceCacheRoot</code> option can be used to specify an alternative path, which can be absolute or relative. In the latter case the path is interpreted relative to the target directory for the generated executable specified via option <code>-H:Path</code> (which defaults to the current working directory). As an example, the following variant of the previous command specifies an absolute temporary directory path constructed using the current process <code>id</code>:</p> <pre><code>SOURCE_CACHE_ROOT=/tmp/$$/sources\nnative-image -g \\\n    -H:-SpawnIsolates \\\n    -H:DebugInfoSourceCacheRoot=$SOURCE_CACHE_ROOT \\\n    -H:DebugInfoSourceSearchPath=apps/hello/target/hello-sources.jar,apps/greeter/target/greeter-sources.jar \\\n    -cp apps/target/hello.jar:apps/target/greeter.jar \\\n    org.my.Hello\n</code></pre> <p>The resulting cache directory will be something like <code>/tmp/1272696/sources</code>.</p> <p>If the source cache path includes a directory that does not yet exist, it will be created during population of the cache.</p> <p>Note that in all the examples above the <code>DebugInfoSourceSearchPath</code> options are actually redundant. In the first case, the classpath entries for apps/hello/classes and apps/greeter/classes will be used to derive the default search roots apps/hello/src and apps/greeter/src. In the second case, the classpath entries for apps/target/hello.jar and apps/target/greeter.jar will be used to derive the default search roots apps/target/hello-sources.jar and apps/target/greeter-sources.jar.</p>"},{"location":"#supported-features","title":"Supported Features","text":"<p>The currently supported features include:</p> <ul> <li>break points configured by file and line, or by method name</li> <li>single stepping by line including both into and over function calls</li> <li>stack backtraces (not including frames detailing inlined code)</li> <li>printing of primitive values</li> <li>structured (field by field) printing of Java objects</li> <li>casting/printing objects at different levels of generality</li> <li>access through object networks via path expressions</li> <li>reference by name to methods and static field data</li> <li>reference by name to values bound to parameter and local vars</li> <li>reference by name to class constants</li> </ul> <p>Note that single stepping within a compiled method includes file and line number info for inlined code, including inlined GraalVM methods. So, GDB may switch files even though you are still in the same compiled method.</p>"},{"location":"#special-considerations-for-debugging-java-from-gdb","title":"Special considerations for debugging Java from GDB","text":"<p>GDB does not currently include support for Java debugging. In consequence, debug capability has been implemented by generating debug info that models the Java program as an equivalent C++ program.  Java class, array and interface references are actually pointers to records that contain the relevant field/array data. In the corresponding C++ model the Java name is used to label the underlying C++ (class/struct) layout types and Java references appear as pointers.</p> <p>So, for example in the DWARF debug info model <code>java.lang.String</code> identifies a C++ class. This class layout type declares the expected fields like <code>hash</code> of type <code>int</code> and <code>value</code> of type <code>byte[]</code> and methods like <code>String(byte[])</code>, <code>charAt(int)</code>, etc. However, the copy constructor which appears in Java as <code>String(String)</code> appears in <code>gdb</code> with the signature <code>String(java.lang.String *)</code>.</p> <p>The C++ layout class inherits fields and methods from class (layout) type <code>java.lang.Object</code> using C++ public inheritance. The latter in turn inherits standard oop (ordinary object pointer) header fields from a special struct class named <code>_objhdr</code> which includes two fields. The first field is called <code>hub</code> and its type is <code>java.lang.Class *</code> i.e. it is a pointer to the object's class. The second field is called <code>idHash</code> and has type <code>int</code>. It stores an identity hashcode for the object.</p> <p>The <code>ptype</code> command can be used to print details of a specific type. Note that the Java type name must be specified in quotes because to escape the embedded <code>.</code> characters.</p> <pre><code>(gdb) ptype 'java.lang.String'\ntype = class java.lang.String : public java.lang.Object {\n  private:\n    byte [] *value;\n    int hash;\n    byte coder;\n\n  public:\n    void String(byte [] *);\n    void String(char [] *);\n    void String(byte [] *, java.lang.String *);\n    . . .\n    char charAt(int);\n    . . .\n    java.lang.String * concat(java.lang.String *);\n    . . .\n}\n</code></pre> <p>The ptype command can also be used to identify the static type of a Java data value. The current example session is for a simple hello world program. Main method <code>Hello.main</code> is passed a single parameter <code>args</code> whose Java type is <code>String[]</code>. If the debugger is stopped at entry to <code>main</code> we can use <code>ptype</code> to print the type of <code>args</code>.</p> <p>``` (gdb) ptype args type = class java.lang.String[] : public java.lang.Object {   public:     int len;     java.lang.String *data[0]; } *</p> <pre><code>\nThere are a few details worth highlighting here. Firstly, the debugger\nsees a Java array reference as a pointer type, as it does every Java object\nreference.\n\nSecondly, the pointer points to a structure, actually a C++ class,\nthat models the layout of the Java array using an integer length field\nand a data field whose type is a C++ array embedded into the block of\nmemory that models the array object.\n\nElements of the array data field are references to the base type, in\nthis case pointers to `java.lang.String`. The data array has a nominal\nlength of 0. However, the block of memory allocated for the `String[]`\nobject actually includes enough space to hold the number of pointers\ndetermined by the value of field `len`.\n\nFinally, notice that the C++ class `java.lang.String[]` inherits from\nthe C++ class `java.lang.Object`. So, an array is still also an object.\nIn particular, as we will see when we print the object contents, this\nmeans that every array also includes the object header fields that all\nJava objects share.\n\nThe print command can be used to display the object reference as a memory\naddress. \n\n</code></pre> <p>(gdb) print args $1 = (java.lang.String[] *) 0x7ffff7c01130</p> <pre><code>\nIt can also be used to print the contents of the object field by field. This\nis achieved by dereferencing the pointer using the `*` operator.\n\n</code></pre> <p>(gdb) print *args $2 = {    = {     &lt;_objhdr&gt; = {       hub = 0xaa90f0,       idHash = 0     }, },    members of java.lang.String[]:   len = 1,   data = 0x7ffff7c01140 } <pre><code>\nThe array object contains embedded fields inherited from class\n`_objhdr` via parent class `Object`. `_objhdr` is a synthetic type\nadded to the deubg info to model fields that are present at the start\nof all objects. They include `hub` which is a reference to the object's\nclass and `hashId` a unique numeric hash code.\n\nClearly, the debugger knows the type (`java.lang.String[]`) and location\nin memory (`0x7ffff7c010b8`) of local variable `args`. It also knows about\nthe layout of the fields embedded in the referenced object. This means\nit is possible to use the C++ `.` and `-&gt;` operators in debugger commands\nto traverse the underlying object data structures.\n\n</code></pre> <p>(gdb) print args-&gt;data[0] $3 = (java.lang.String ) 0x7ffff7c01160 (gdb) print args-&gt;data[0] $4 = {     = {      &lt;_objhdr&gt; = {       hub = 0xaa3350      }, },    members of java.lang.String:    value = 0x7ffff7c01180,    hash = 0,    coder = 0 '\\000'  } (gdb) print *args-&gt;data[0]-&gt;value $5 = {    = {     &lt;_objhdr&gt; = {       hub = 0xaa3068,       idHash = 0     }, },    members of byte []:   len = 6,   data = 0x7ffff7c01190 \"Andrew\" }  ``` <p>Returning to the <code>hub</code> field in the object header it was mentioned before that this is actually a reference to the object's class. This is actually an instance of Java type <code>java.lang.Class</code>. Note that the field is typed by gdb using a pointer to the underlying C++ class (layout) type.</p> <pre><code>(gdb) print args-&gt;hub\n$6 = (java.lang.Class *) 0xaa90f0\n</code></pre> <p>All classes, from Object downwards inherit from a common, automatically generated header type <code>_objhdr</code>. It is this header type which includes the <code>hub</code> field:</p> <pre><code>(gdb) ptype _objhdr\ntype = struct _objhdr {\n    java.lang.Class *hub;\n    int idHash;\n}\n\n(gdb) ptype 'java.lang.Object'\ntype = class java.lang.Object : public _objhdr {\n  public:\n    void Object(void);\n    . . .\n</code></pre> <p>The fact that all objects have a common header pointing to a class makes it possible to perform a simple test to decide if an address is an object reference and, if so,  what the object's class is. Given a valid object reference it is always possible to print the contents of the <code>String</code> referenced from the <code>hub</code>'s name field.</p> <p>Note that as a consequence, this allows every object observed by the debugger to be downcast to its dynamic type. i.e. even if the debugger only sees the static type of e.g. java.nio.file.Path we can easily downcast to the dynamic type, which might be a subtype such as <code>jdk.nio.zipfs.ZipPath</code>, thus making it possible to inspect fields that we would not be able to observe from the static type alone. First the value is cast to an object reference. Then a path expression is used to dereference through the the <code>hub</code> field and the <code>hub</code>'s name field to the <code>byte[]</code> value array located in the name <code>String</code>.</p> <pre><code>(gdb) print/x ((_objhdr *)$rdi)\n$7 = (_objhdr *) 0x7ffff7c01130\n(gdb) print *$7-&gt;hub-&gt;name-&gt;value\n$8 = {\n  &lt;java.lang.Object&gt; = {\n    &lt;_objhdr&gt; = {\n      hub = 0xaa3068,\n      idHash = 178613527\n    }, &lt;No data fields&gt;}, \n   members of byte []:\n   len = 19,\n  data = 0x8779c8 \"[Ljava.lang.String;\"\n }\n</code></pre> <p>The value in register <code>rdi</code> is obviously a reference to a String array. Indeed, this is no coincidence. The example session has stopped at a break point placed at the entry to <code>Hello.main</code> and at that point the value for the <code>String[]</code> parameter <code>args</code> will be located in register <code>rdi</code>. Looking back we can see that the value in <code>rdi</code> is the same value as was printed by command <code>print args</code>. </p> <p>A simpler command which allows just the name of the <code>hub</code> object to be printed is as follows:</p> <pre><code>(gdb) x/s $7-&gt;hub-&gt;name-&gt;value-&gt;data\n798:    \"[Ljava.lang.String;\"\n</code></pre> <p>Indeed it is useful to define a <code>gdb</code> command <code>hubname_raw</code> to execute this operation on an arbitrary raw memory address.</p> <pre><code>define hubname_raw\n  x/s (('java.lang.Object' *)($arg0))-&gt;hub-&gt;name-&gt;value-&gt;data\nend\n\n(gdb) hubname_raw $rdi\n0x8779c8:   \"[Ljava.lang.String;\"\n</code></pre> <p>Attempting to print the hub name for an invalid reference will fail safe, printing an error message.</p> <pre><code>(gdb) p/x $rdx\n$5 = 0x2\n(gdb) hubname $rdx\nCannot access memory at address 0x2\n</code></pre> <p>If <code>gdb</code> already knows the Java type for a reference it can be printed without casting using a simpler version of the hubname command. For example, the String array retrieved above as <code>$1</code> has a known type.</p> <pre><code>(gdb) ptype $1\ntype = class java.lang.String[] : public java.lang.Object {\n    int len;\n    java.lang.String *data[0];\n} *\n\ndefine hubname\n  x/s (($arg0))-&gt;hub-&gt;name-&gt;value-&gt;data\nend\n\n(gdb) hubname $1\n0x8779c8:   \"[Ljava.lang.String;\"\n</code></pre> <p>The native image heap contains a unique hub object (i.e. instance of <code>java.lang.Class</code>) for every Java type that is included in the image. It is possible to refer to these class constants using the standard Java class literal syntax:</p> <pre><code>(gdb) print 'Hello.class'\n$6 = {\n  &lt;java.lang.Object&gt; = {\n    &lt;_objhdr&gt; = {\n      hub = 0xaabd00,\n      idHash = 1589947226\n    }, &lt;No data fields&gt;}, \n  members of java.lang.Class:\n  typeCheckStart = 13,\n  name = 0xbd57f0,\n  ...\n</code></pre> <p>Unfortunately it is necessary to quote the class constant literal to avoid gdb interpreting the embedded <code>.</code> character as a field access.</p> <p>Note that the type of a class constant literal is <code>java.lang.Class</code> rather than <code>java.lang.Class *</code>.</p> <p>Class constants exist for Java instance classes, interfaces, array classes and arrays, including primitive arrays:</p> <pre><code>(gdb)  print 'java.util.List.class'.name\n$7 = (java.lang.String *) 0xb1f698\n(gdb) print 'java.lang.String[].class'.name-&gt;value-&gt;data\n$8 = 0x8e6d78 \"[Ljava.lang.String;\"\n(gdb) print 'long.class'.name-&gt;value-&gt;data\n$9 = 0xc87b78 \"long\"\n(gdb) x/s  'byte[].class'.name-&gt;value-&gt;data\n0x925a00:   \"[B\"\n(gdb) \n</code></pre> <p>Interface layouts are modelled as C++ union types. The members of the union include the C++ layout types for all Java classes which implement the interface.</p> <pre><code>(gdb) ptype 'java.lang.CharSequence'\ntype = union java.lang.CharSequence {\n    java.nio.CharBuffer _java.nio.CharBuffer;\n    java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;\n    java.lang.String _java.lang.String;\n    java.lang.StringBuilder _java.lang.StringBuilder;\n    java.lang.StringBuffer _java.lang.StringBuffer;\n}\n</code></pre> <p>Given a reference typed to an interface it can be resolved to the relevant class type by viewing it through the relevant union element.</p> <p>If we take the first String in the args array we can ask <code>gdb</code> to cast it to interface <code>CharSequence</code>.</p> <pre><code>(gdb) print args-&gt;data[0]\n$10 = (java.lang.String *) 0x7ffff7c01160\n(gdb) print ('java.lang.CharSequence' *)$10\n$11 = (java.lang.CharSequence *) 0x7ffff7c01160\n</code></pre> <p>The <code>hubname</code> command will not work with this union type because it is only objects of the elements of the union that include the <code>hub</code> field:</p> <pre><code>(gdb) hubname $11\nThere is no member named hub.\n</code></pre> <p>However, since all elements include the same header any one of them can be passed to <code>hubname</code> in order to identify the actual type. This allows the correct union element to be selected:</p> <pre><code>(gdb) hubname $11-&gt;'_java.nio.CharBuffer'\n0x95cc58:   \"java.lang.String`\\302\\236\"\n(gdb) print $11-&gt;'_java.lang.String'\n$12 = {\n  &lt;java.lang.Object&gt; = {\n    &lt;_objhdr&gt; = {\n      hub = 0xaa3350,\n      idHash = 0\n    }, &lt;No data fields&gt;},\n  members of java.lang.String:\n  hash = 0,\n  value = 0x7ffff7c01180,\n  coder = 0 '\\000'\n}\n</code></pre> <p>Notice that the printed class name for <code>hub</code> includes some trailing characters. That is because a data array storing Java String text is not guaranteed to be zero-terminated.</p> <p>The debugger does not just understand the name and type of local and parameter variables. It also knows about method names and static field names.</p> <p>The following command places a breakpoint on the main entry point for class <code>Hello</code>. Note that since GDB thinks this is a C++ method it uses the <code>::</code> separator to separate the method name from the class name.</p> <pre><code>(gdb) info func ::main\nAll functions matching regular expression \"::main\":\n\nFile Hello.java:\n    void Hello::main(java.lang.String[] *);\n(gdb) x/4i Hello::main\n=&gt; 0x4065a0 &lt;Hello::main(java.lang.String[] *)&gt;:    sub    $0x8,%rsp\n   0x4065a4 &lt;Hello::main(java.lang.String[] *)+4&gt;:  cmp    0x8(%r15),%rsp\n   0x4065a8 &lt;Hello::main(java.lang.String[] *)+8&gt;:  jbe    0x4065fd &lt;Hello::main(java.lang.String[] *)+93&gt;\n   0x4065ae &lt;Hello::main(java.lang.String[] *)+14&gt;: callq  0x406050 &lt;Hello$Greeter::greeter(java.lang.String[] *)&gt;\n(gdb) b Hello::main\nBreakpoint 1 at 0x4065a0: file Hello.java, line 43.\n</code></pre> <p>An example of a static field containing Object data is provided by the static field <code>powerCache</code> in class <code>BigInteger</code>.</p> <pre><code>(gdb) ptype 'java.math.BigInteger'\ntype = class _java.math.BigInteger : public _java.lang.Number {\n  public:\n    int [] mag;\n    int signum;\n  private:\n    int bitLengthPlusOne;\n    int lowestSetBitPlusTwo;\n    int firstNonzeroIntNumPlusTwo;\n    static java.math.BigInteger[][] powerCache;\n    . . .\n  public:\n    void BigInteger(byte [] *);\n    void BigInteger(java.lang.String *, int);\n    . . .\n}\n(gdb) info var powerCache\nAll variables matching regular expression \"powerCache\":\n\nFile java/math/BigInteger.java:\n    java.math.BigInteger[][] *java.math.BigInteger::powerCache;\n</code></pre> <p>The static variable name can be used to refer to the value stored in this field. Note also that the address operator can be used identify the location (address) of the field in the heap.</p> <pre><code>(gdb) p 'java.math.BigInteger'::powerCache\n$13 = (java.math.BigInteger[][] *) 0xced5f8\n(gdb) p &amp;'java.math.BigInteger'::powerCache\n$14 = (java.math.BigInteger[][] **) 0xced3f0\n</code></pre> <p>The debugger dereferences through symbolic names for static fields to access the primitive value or object stored in the field.</p> <pre><code>(gdb) p *'java.math.BigInteger'::powerCache\n$15 = {\n  &lt;java.lang.Object&gt; = {\n    &lt;_objhdr&gt; = {\n    hub = 0xb8dc70,\n    idHash = 1669655018\n    }, &lt;No data fields&gt;},\n  members of _java.math.BigInteger[][]:\n  len = 37,\n  data = 0xced608\n}\n(gdb) p 'java.math.BigInteger'::powerCache-&gt;data[0]@4\n$16 = {0x0, 0x0, 0xed5780, 0xed5768}\n(gdb) p *'java.math.BigInteger'::powerCache-&gt;data[2]\n$17 = {\n  &lt;java.lang.Object&gt; = {\n    &lt;_objhdr&gt; = {\n    hub = 0xabea50,\n    idHash = 289329064\n    }, &lt;No data fields&gt;},\n  members of java.math.BigInteger[]:\n  len = 1,\n  data = 0xed5790\n}\n(gdb) p *'java.math.BigInteger'::powerCache-&gt;data[2]-&gt;data[0]\n$18 = {\n  &lt;java.lang.Number&gt; = {\n    &lt;java.lang.Object&gt; = {\n      &lt;_objhdr&gt; = {\n        hub = 0xabed80\n      }, &lt;No data fields&gt;}, &lt;No data fields&gt;},\n  members of java.math.BigInteger:\n  mag = 0xcbc648,\n  signum = 1,\n  bitLengthPlusOne = 0,\n  lowestSetBitPlusTwo = 0,\n  firstNonzeroIntNumPlusTwo = 0\n}\n</code></pre>"},{"location":"#identifying-source-code-location","title":"Identifying Source Code Location","text":"<p>One goal of the implementation is to make it simple to configure the debugger so that it can identify the relevant source file when it stops during program execution. The <code>native-image</code> tool tries to achieve this by accumulating the relevant sources in a suitably structured file cache.</p> <p>The <code>native-image</code> tool uses different strategies to locate source files for JDK runtime classes, GraalVM classes, and application source classes for inclusion in the local sources cache. It identifies which strategy to use based on the package name of the class. So, for example, packages starting with <code>java.*</code> or <code>jdk.*</code> are JDK classes; packages starting with <code>org.graal.*</code> or <code>com.oracle.svm.*</code> are GraalVM classes; any other packages are regarded as application classes.</p> <p>Sources for JDK runtime classes are retrieved from the src.zip found in the JDK release used to run the native image generation process. Retrieved files are cached under subdirectory sources, using the module name (for JDK11) and package name of the associated class to define the directory hierarchy in which the source is located.</p> <p>For example, on Linux the source for <code>class java.util.HashMap</code> will be cached in file sources/java.base/java/util/HashMap.java. Debug info records for this class and its methods will identify this source file using the relative directory path java.base/java/util and file name HashMap.java. On Windows things will be the same modulo use of <code>\\</code> rather than <code>/</code> as the file separator.</p> <p>Sources for GraalVM classes are retrieved from ZIP files or source directories derived from entries in the classpath. Retrieved files are cached under subdirectory sources, using the package name of the associated class to define the directory hierarchy in which the source is located (e.g., class <code>com.oracle.svm.core.VM</code> has its source file cached at <code>sources/com/oracle/svm/core/VM.java</code>).</p> <p>The lookup scheme for cached GraalVM sources varies depending upon what is found in each classpath entry. Given a JAR file entry like /path/to/foo.jar, the corresponding file /path/to/foo.src.zip is considered as a candidate ZIP file system from which source files may be extracted. When the entry specifies a directory like /path/to/bar, then directories /path/to/bar/src and /path/to/bar/src_gen are considered as candidates. Candidates are skipped when the ZIP file or source directory does not exist, or it does not contain at least one subdirectory hierarchy that matches one of the the expected GraalVM package hierarchies.</p> <p>Sources for application classes are retrieved from source JAR files or source directories derived from entries in the classpath. Retrieved files are cached under subdirectory sources, using the package name of the associated class to define the directory hierarchy in which the source is located (e.g., class <code>org.my.foo.Foo</code> has its source file cached as <code>sources/org/my/foo/Foo.java</code>).</p> <p>The lookup scheme for cached application sources varies depending upon what is found in each classpath entry. Given a JAR file entry like /path/to/foo.jar, the corresponding JAR /path/to/foo-sources.jar is considered as a candidate ZIP file system from which source files may be extracted. When the entry specifies a dir like /path/to/bar/classes or /path/to/bar/target/classes then one of the directories /path/to/bar/src/main/java, /path/to/bar/src/java or /path/to/bar/src is selected as a candidate (in that order of preference). Finally, the current directory in which the native executable is being run is also considered as a candidate.</p> <p>These lookup strategies are only provisional and may need extending in the future. However, it is possible to make missing sources available by other means. One option is to unzip extra app source JAR files, or copy extra app source trees into the cache. Another is to configure extra source search paths.</p>"},{"location":"#configuring-source-paths-in-gnu-debugger","title":"Configuring Source Paths in GNU Debugger","text":"<p>By default, GDB will employ the local directory root <code>sources</code> to locate the source files for your application classes, GraalVM classes, and JDK runtime classes. If the sources cache is not located in the directory in which you run GDB, you can configure the required paths using the following command:</p> <pre><code>(gdb) set directories /path/to/sources/\n</code></pre> <p>The argument to the set directories command should identify the location of the sources cache as an absolute path or a relative path from the working directory of the <code>gdb</code> session.</p> <p>Note that the current implementation does not yet find some sources for the GraalVM JIT compiler in the org.graalvm.compiler* package subspace.</p> <p>You can supplement the files cached in <code>sources</code> by unzipping application source JAR files or copying application source trees into the cache. You will need to ensure that any new subdirectory you add to <code>sources</code> corresponds to the top level package for the classes whose sources are being included.</p> <p>You can also add extra directories to the search path using the <code>set directories</code> command:</p> <pre><code>(gdb) set directories /path/to/my/sources/:/path/to/my/other/sources\n</code></pre> <p>Note that the GNU Debugger does not understand ZIP format file systems so any extra entries you add must identify a directory tree containing the relevant sources. Once again, top level entries in the directory added to the search path must correspond to the top level package for the classes whose sources are being included.</p>"},{"location":"#checking-debug-info-on-linux","title":"Checking Debug Info on Linux","text":"<p>Note that this is only of interest to those who want to understand how the debug info implementation works or want to troubleshoot problems encountered during debugging that might relate to the debug info encoding.</p> <p>The <code>objdump</code> command can be used to display the debug info embedded into a native executable. The following commands (which all assume the target binary is called <code>hello</code>) can be used to display all generated content:</p> <pre><code>objdump --dwarf=info hello &gt; info\nobjdump --dwarf=abbrev hello &gt; abbrev\nobjdump --dwarf=ranges hello &gt; ranges\nobjdump --dwarf=decodedline hello &gt; decodedline\nobjdump --dwarf=rawline hello &gt; rawline\nobjdump --dwarf=str hello &gt; str\nobjdump --dwarf=loc hello &gt; loc\nobjdump --dwarf=frames hello &gt; frames\n</code></pre> <p>The info section includes details of all compiled Java methods.</p> <p>The abbrev section defines the layout of records in the info section that describe Java files (compilation units) and methods.</p> <p>The ranges section details the start and end addresses of method code segments.</p> <p>The decodedline section maps subsegments of method code range segments to files and line numbers. This mapping includes entries for files and line numbers for inlined methods.</p> <p>The rawline segment provides details of how the line table is generated using DWARF state machine instructions that encode file, line, and address transitions.</p> <p>The loc section provides details of address ranges within which parameter and local variables declared in the info section are known to have a determinate value. The details identify where the value is located, either in a machine register, on the stack or at a specific address in memory.</p> <p>The str section provides a lookup table for strings referenced from records in the info section.</p> <p>The frames section lists transition points in compiled methods where a (fixed size) stack frame is pushed or popped, allowing the debugger to identify each frame's current and previous stack pointers and its return address.</p> <p>Note that some of the content embedded in the debug records is generated by the C compiler and belongs to code that is either in libraries or the C lib bootstrap code that is bundled in with the Java method code.</p>"},{"location":"#currently-supported-targets","title":"Currently Supported Targets","text":"<p>The prototype is currently implemented only for the GNU Debugger on Linux:</p> <ul> <li> <p>Linux/x86_64 support has been tested and should work correctly</p> </li> <li> <p>Linux/AArch64 support is present but has not yet been fully verified (break points should work ok but stack backtraces may be incorrect)</p> </li> </ul> <p>Windows support is still under development.</p>"},{"location":"#debugging-with-isolates","title":"Debugging with Isolates","text":"<p>Enabling the use of isolates, by passing command line option <code>-H:-SpawnIsolates</code> to the <code>native-image</code> builder, affects the way ordinary object pointers (oops) are encoded. In turn, that means the debug info generator has to provide <code>gdb</code> with information about how to translate an encoded oop to the address in memory, where the object data is stored. This sometimes requires care when asking <code>gdb</code> to process encoded oops vs decoded raw addresses.</p> <p>When isolates are disabled, oops are essentially raw addresses pointing directly at the object contents. This is generally the same whether the oop is embedded in a static/instance field or is referenced from a local or parameter variable located in a register or saved to the stack. It is not quite that simple because the bottom 3 bits of some oops may be used to hold \"tags\" that record certain transient properties of an object. However, the debug info provided to <code>gdb</code> means that it will remove these tag bits before dereferencing the oop as an address.</p> <p>By contrast, when isolates are enabled, oops references stored in static or instance fields are actually relative addresses, offsets from a dedicated heap base register (r14 on x86_64, r29 on AArch64), rather than direct addresses (in a few special cases the offset may also have some low tag bits set). When an \"indirect\" oop of this kind gets loaded during execution, it is almost always immediately converted to a \"raw\" address by adding the offset to the heap base register value. So, oops which occur as the value of local or parameter vars are actually raw addresses.</p> <p>Note that on some operating systems enabling isolates causes problems with printing of objects when using a <code>gdb</code> release version 10 or earlier. It is currently recommended to disable use of isolates, by passing command line option <code>-H:-SpawnIsolates</code>, when generating debug info if your operating system includes one of these earlier releases. Alternatively, you may be able to upgrade your debugger to a later version.</p> <p>The DWARF info encoded into the image, when isolates are enabled, tells <code>gdb</code> to rebase indirect oops whenever it tries to dereference them to access underlying object data. This is normally automatic and transparent, but it is visible in the underlying type model that <code>gdb</code> displays when you ask for the type of objects.</p> <p>For example, consider the static field we encountered above. Printing its type in an image that uses isolates shows that this static field has a different type to the expected one:</p> <pre><code>(gdb) ptype 'java.math.BigInteger'::powerCache\ntype = class _z_.java.math.BigInteger[][] : public java.math.BigInteger[][] {\n} *\n</code></pre> <p>The field is typed as <code>_z_.java.math.BigInteger[][]</code> which is an empty wrapper class that inherits from the expected type <code>java.math.BigInteger[][]</code>. This wrapper type is essentially the same as the original but the DWARF info record that defines it includes information that tells gdb how to convert pointers to this type.</p> <p>When <code>gdb</code> is asked to print the oop stored in this field it is clear that it is an offset rather than a raw address.</p> <pre><code>(gdb) p/x 'java.math.BigInteger'::powerCache\n$1 = 0x286c08\n(gdb) x/x 0x286c08\n0x286c08:   Cannot access memory at address 0x286c08\n</code></pre> <p>However, when <code>gdb</code> is asked to dereference through the field, it applies the necessary address conversion to the oop and fetches the correct data.</p> <pre><code>(gdb) p/x *'java.math.BigInteger'::powerCache\n$2 = {\n  &lt;java.math.BigInteger[][]&gt; = {\n    &lt;java.lang.Object&gt; = {\n      &lt;_objhdr&gt; = {\n        hub = 0x1ec0e2,\n        idHash = 0x2f462321\n      }, &lt;No data fields&gt;},\n    members of java.math.BigInteger[][]:\n    len = 0x25,\n    data = 0x7ffff7a86c18\n  }, &lt;No data fields&gt;}\n</code></pre> <p>Printing the type of the <code>hub</code> field or the data array shows that they are also modelled using indirect types:</p> <pre><code>(gdb) ptype $1-&gt;hub\ntype = class _z_.java.lang.Class : public java.lang.Class {\n} *\n(gdb) ptype $2-&gt;data\ntype = class _z_.java.math.BigInteger[] : public java.math.BigInteger[] {\n} *[0]\n</code></pre> <p>The debugger still knows how to dereference these oops:</p> <pre><code>(gdb) p $1-&gt;hub\n$3 = (_z_.java.lang.Class *) 0x1ec0e2\n(gdb) x/x $1-&gt;hub\n0x1ec0e2:   Cannot access memory at address 0x1ec0e2\n(gdb) p *$1-&gt;hub\n$4 = {\n  &lt;java.lang.Class&gt; = {\n    &lt;java.lang.Object&gt; = {\n      &lt;_objhdr&gt; = {\n        hub = 0x1dc860,\n        idHash = 1530752816\n      }, &lt;No data fields&gt;},\n    members of java.lang.Class:\n    name = 0x171af8,\n    . . .\n  }, &lt;No data fields&gt;}\n\n</code></pre> <p>Since the indirect types inherit from the corresponding raw type it is possible to use an expression that identifies an indirect type pointer in almost all cases where an expression identifying a raw type pointer would work. The only case case where care might be needed is when casting a displayed numeric field value or displayed register value.</p> <p>For example, if the indirect <code>hub</code> oop printed above is passed to <code>hubname_raw</code>, the cast to type Object internal to that command fails to force the required indirect oops translation. The resulting memory access fails:</p> <pre><code>(gdb) hubname_raw 0x1dc860\nCannot access memory at address 0x1dc860\n</code></pre> <p>In this case it is necessary to use a slightly different command that casts its argument to an indirect pointer type:</p> <pre><code>(gdb) define hubname_indirect\n x/s (('_z_.java.lang.Object' *)($arg0))-&gt;hub-&gt;name-&gt;value-&gt;data\nend\n(gdb) hubname_indirect 0x1dc860\n0x7ffff78a52f0: \"java.lang.Class\"\n</code></pre>"},{"location":"#debugging-helper-methods","title":"Debugging Helper Methods","text":"<p>On platforms where the debugging information is not fully supported, or when debugging complex issues, it can be helpful to print or query high-level information about the Native Image execution state. For those scenarios, Native Image provides debug helper methods that can be embedded into a native executable by specifying the build-time option <code>-H:+IncludeDebugHelperMethods</code>. While debugging, it is then possible to invoke those debug helper methods like any normal C method. This functionality is compatible with pretty much any debugger.</p> <p>While debugging with gdb, the following command can be used to list all debug helper methods that are embedded into the native image:</p> <pre><code>(gdb) info functions svm_dbg_\n</code></pre> <p>Before invoking a method, it is best to directly look at the source code of the Java class <code>DebugHelper</code> to determine which arguments each method expects. For example, calling the method below prints high-level information about the Native Image execution state similar to what is printed for a fatal error:</p> <pre><code>(gdb) call svm_dbg_print_fatalErrorDiagnostics($r15, $rsp, $rip)\n</code></pre>"},{"location":"#special-considerations-for-using-perf-and-valgrind","title":"Special Considerations for using perf and valgrind","text":"<p>Debug info includes details of address ranges for top level and inlined compiled method code as well as mappings from code addresses to the corresponding source files and lines. <code>perf</code> and <code>valgrind</code> are able to use this information for some of their recording and reporting operations. For example, <code>perf report</code> is able to associate code adresses sampled during a <code>perf record</code> session with Java methods and print the DWARF-derived method name for the method in its output histogram.</p> <pre><code>    . . .\n    68.18%     0.00%  dirtest          dirtest               [.] _start\n            |\n            ---_start\n               __libc_start_main_alias_2 (inlined)\n               |          \n               |--65.21%--__libc_start_call_main\n               |          com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_5087f5482cc9a6abc971913ece43acb471d2631b (inlined)\n               |          com.oracle.svm.core.JavaMainWrapper::run (inlined)\n               |          |          \n               |          |--55.84%--com.oracle.svm.core.JavaMainWrapper::runCore (inlined)\n               |          |          com.oracle.svm.core.JavaMainWrapper::runCore0 (inlined)\n               |          |          |          \n               |          |          |--55.25%--DirTest::main (inlined)\n               |          |          |          |          \n               |          |          |           --54.91%--DirTest::listAll (inlined)\n               . . .\n</code></pre> <p>Unfortunately, other operations require Java methods to be identified by an ELF (local) function symbol table entry locating the start of the compiled method code. In particular, assembly code dumps provided by both tools identify branch and call targets using an offset from the nearest symbol. Omitting Java method symbols means that offsets are generally displayed relative to some unrelated global symbol, usually the entry point for a method exported for invocation by C code.</p> <p>As an illustration of the problem, the following excerpted output from <code>perf annotate</code> displays the first few annotated instructions of the compiled code for method <code>java.lang.String::String()</code>.</p> <pre><code>    . . .\n         : 501    java.lang.String::String():\n         : 521    public String(byte[] bytes, int offset, int length, Charset charset) {\n    0.00 :   519d50: sub    $0x68,%rsp\n    0.00 :   519d54: mov    %rdi,0x38(%rsp)\n    0.00 :   519d59: mov    %rsi,0x30(%rsp)\n    0.00 :   519d5e: mov    %edx,0x64(%rsp)\n    0.00 :   519d62: mov    %ecx,0x60(%rsp)\n    0.00 :   519d66: mov    %r8,0x28(%rsp)\n    0.00 :   519d6b: cmp    0x8(%r15),%rsp\n    0.00 :   519d6f: jbe    51ae1a &lt;graal_vm_locator_symbol+0xe26ba&gt;\n    0.00 :   519d75: nop\n    0.00 :   519d76: nop\n         : 522    Objects.requireNonNull(charset);\n    0.00 :   519d77: nop\n         : 524    java.util.Objects::requireNonNull():\n         : 207    if (obj == null)\n    0.00 :   519d78: nop\n    0.00 :   519d79: nop\n         : 209    return obj;\n    . . .\n</code></pre> <p>The leftmost column shows percentages for the amount of time recorded at each instruction in samples obtained during the <code>perf record</code> run. Each instruction is prefaced with it's address in the program's code section. The disassembly interleaves the source lines from which the code is derived, 521-524 for the top level code and 207-209 for the code inlined from from <code>Objects.requireNonNull()</code>. Also, the start of the method is labelled with the name defined in the DWARF debug info, <code>java.lang.String::String()</code>. However, the branch instruction <code>jbe</code> at address <code>0x519d6f</code> uses a very large offset from <code>graal_vm_locator_symbol</code>. The printed offset does identify the correct address relative to the location of the symbol. However, this fails to make clear that the target address actually lies within the compiled code range for method <code>String::String()</code> i.e. that thsi is a method-local branch.</p> <p>Readability of the tool output is significantly improved if option <code>-H-DeleteLocalSymbols</code> is passed to the <code>native-image</code> command. The equivalent <code>perf annotate</code> output with this option enabled is as follows:</p> <pre><code>    . . .\n         : 5      000000000051aac0 &lt;String_constructor_f60263d569497f1facccd5467ef60532e990f75d&gt;:\n         : 6      java.lang.String::String():\n         : 521    *          {@code offset} is greater than {@code bytes.length - length}\n         : 522    *\n         : 523    * @since  1.6\n         : 524    */\n         : 525    @SuppressWarnings(\"removal\")\n         : 526    public String(byte[] bytes, int offset, int length, Charset charset) {\n    0.00 :   51aac0: sub    $0x68,%rsp\n    0.00 :   51aac4: mov    %rdi,0x38(%rsp)\n    0.00 :   51aac9: mov    %rsi,0x30(%rsp)\n    0.00 :   51aace: mov    %edx,0x64(%rsp)\n    0.00 :   51aad2: mov    %ecx,0x60(%rsp)\n    0.00 :   51aad6: mov    %r8,0x28(%rsp)\n    0.00 :   51aadb: cmp    0x8(%r15),%rsp\n    0.00 :   51aadf: jbe    51bbc1 &lt;String_constructor_f60263d569497f1facccd5467ef60532e990f75d+0x1101&gt;\n    0.00 :   51aae5: nop\n    0.00 :   51aae6: nop\n         : 522    Objects.requireNonNull(charset);\n    0.00 :   51aae7: nop\n         : 524    java.util.Objects::requireNonNull():\n         : 207    * @param &lt;T&gt; the type of the reference\n         : 208    * @return {@code obj} if not {@code null}\n         : 209    * @throws NullPointerException if {@code obj} is {@code null}\n         : 210    */\n         : 211    public static &lt;T&gt; T requireNonNull(T obj) {\n         : 212    if (obj == null)\n    0.00 :   51aae8: nop\n    0.00 :   51aae9: nop\n         : 209    throw new NullPointerException();\n         : 210    return obj;\n    . . .\n</code></pre> <p>In this version the start address of the method is now labelled with the mangled symbol name <code>String_constructor_f60263d569497f1facccd5467ef60532e990f75d</code> as well as the DWARF name. The branch target is now printed using an offset from that start symbol.</p> <p>Unfortunately, <code>perf</code> and <code>valgrind</code> do not correctly understand the mangling algorithm employed by GraalVM, nor are they currently able to replace the mangled name with the DWARF name in the disassembly even though both symbol and DWARF function data are known to identify code starting at the same address. So, the branch instruction still prints its target using a symbol plus offset but it is at least using the method symbol this time.</p> <p>Also, because address <code>51aac0</code> is now recognized as a method start, <code>perf</code> has preceded the first line of the method with 5 context lines, which list the tail end of the method's javadoc comment. Unfortunately, perf has numbered these lines incorrectly, labelling the first comment with 521 rather than 516.</p> <p>Executing command <code>perf annotate</code> will provide a disassembly listing for all methods and C functions in the image. It is possible to annotate a specific method by passing it's name as an argument to the perf annotate command. Note, however, that <code>perf</code> requries the mangled symbol name as argument rather than the DWARF name. So, in order to annotate method <code>java.lang.String::String()</code> it is necessary to run command <code>perf annotate String_constructor_f60263d569497f1facccd5467ef60532e990f75d</code>.</p> <p>The <code>valgrind</code> tool <code>callgrind</code> also requires local symbols to be retained in order to provide high quality output. When <code>callgrind</code> is used in combination with a viewer like <code>kcachegrind</code> it is possible to identify a great deal of valuable information about native image execution aand relate it back to specific source code lines.</p>"},{"location":"#call-graph-recording-with-perf-record","title":"Call-graph recording with <code>perf record</code>","text":"<p>Normally when perf does stack frame recording (i.e. when <code>--call-graph</code> is used), it uses frame pointers to recognize the individual stack frames. This assumes that the executable that gets profiled actually preserves frame pointers whenever a function gets called. For native images, this can be achieved by using <code>-H:+PreserveFramePointer</code> as an image build argument.</p> <p>An alternative solution is to make perf use dwarf debug info (specifically debug_frame data) to help unwind stack frames. To make this work, the image needs to be built with <code>-g</code> (to generate debuginfo), and <code>perf record</code> needs to use the argument <code>--call-graph dwarf</code> to make sure dwarf debug info (instead of frame pointers) is used for stack unwinding.</p>"},{"location":"#related-documentation_6","title":"Related Documentation","text":"<ul> <li>Debug Native Executables with GDB</li> </ul>"},{"location":"#debugging-and-diagnostics","title":"Debugging and Diagnostics","text":"<p>Native Image provides utilities for debugging and inspecting the produced binary:  - For debugging produced binaries and obtaining performance profile statistics, see Debug Information  - For generating heap dumps, see Heap Dump Support  - For JFR events recording, see JDK Flight Recorder (JFR)  - For checking which methods were included in a native executable or a shared library, use the Inspection Tool  - For an overview of static analysis results, see Static Analysis Reports</p> <p># Dynamic Features of Java</p> <p>When you build a native image, it only includes the reachable elements starting from your application entry point, its dependent libraries, and the JDK classes discovered through a static analysis.  However, the reachability of some elements may not be discoverable due to Java\u2019s dynamic features including reflection, resource access, etc.  If an element is not reachable, it will not be included in the generated binary and this can lead to run time failures.</p> <p>Thus, some dynamic Java features may require special \"treatment\" such as a command line option or provisioning metadata to be compatible with ahead-of-time compilation using Native Image. </p> <p>The reference information here explains how Native Image handles some dynamic features of Java:</p> <ul> <li>Accessing Resources</li> <li>Certificate Management</li> <li>Dynamic Proxy</li> <li>Java Native Interface (JNI)</li> <li>JCA Security Services</li> <li>Reflection</li> <li>URL Protocols</li> </ul>"},{"location":"#dynamic-proxy-in-native-image","title":"Dynamic Proxy in Native Image","text":"<p>Java dynamic proxies, implemented by <code>java.lang.reflect.Proxy</code>, provide a mechanism which enables object level access control by routing all method invocations through <code>java.lang.reflect.InvocationHandler</code>. Dynamic proxy classes are generated from a list of interfaces.</p> <p>Native Image does not provide machinery for generating and interpreting bytecode at run time. Therefore all dynamic proxy classes need to be generated at image build time.</p>"},{"location":"#automatic-detection","title":"Automatic Detection","text":"<p>Native Image employs a simple static analysis that detects calls to <code>java.lang.reflect.Proxy.newProxyInstance(ClassLoader, Class&lt;?&gt;[], InvocationHandler)</code> and <code>java.lang.reflect.Proxy.getProxyClass(ClassLoader, Class&lt;?&gt;[])</code>, then tries to determine the list of interfaces that define dynamic proxies automatically. Given the list of interfaces, Native Image generates proxy classes at image build time and adds them to the native image heap. In addition to generating the dynamic proxy class, the constructor of the generated class that takes a <code>java.lang.reflect.InvocationHandler</code> argument, i.e., the one reflectively invoked by <code>java.lang.reflect.Proxy.newProxyInstance(ClassLoader, Class&lt;?&gt;[], InvocationHandler)</code>, is registered for reflection so that dynamic proxy instances can be allocated at run time.</p> <p>The analysis is limited to situations where the list of interfaces comes from a constant array or an array that is allocated in the same method. For example, in the code snippets bellow the dynamic proxy interfaces can be determined automatically.</p>"},{"location":"#static-final-array","title":"Static Final Array:","text":"<pre><code>class ProxyFactory {\n\n    private static final Class&lt;?&gt;[] interfaces = new Class&lt;?&gt;[]{java.util.Comparator.class};\n\n    static Comparator createProxyInstanceFromConstantArray() {\n        ClassLoader classLoader = ProxyFactory.class.getClassLoader();\n        InvocationHandler handler = new ProxyInvocationHandler();\n        return (Comparator) Proxy.newProxyInstance(classLoader, interfaces, handler);\n    }\n}\n</code></pre> <p>Note that the analysis operates on compiler graphs and not source code. Therefore the following ways to declare and populate an array are equivalent from the point of view of the analysis:</p> <pre><code>private static final Class&lt;?&gt;[] interfacesArrayPreInitialized = new Class&lt;?&gt;[]{java.util.Comparator.class};\n</code></pre> <pre><code>private static final Class&lt;?&gt;[] interfacesArrayLiteral = {java.util.Comparator.class};\n</code></pre> <pre><code>private static final Class&lt;?&gt;[] interfacesArrayPostInitialized = new Class&lt;?&gt;[1];\nstatic {\n    interfacesArrayPostInitialized[0] = java.util.Comparator.class;\n}\n</code></pre> <p>However, there are no immutable arrays in Java. Even if the array is declared as <code>static final</code>, its contents can change later on. The simple analysis employed here does not track further changes to the array.</p>"},{"location":"#new-array","title":"New Array:","text":"<pre><code>class ProxyFactory {\n\n    static Comparator createProxyInstanceFromNewArray() {\n        ClassLoader classLoader = ProxyFactory.class.getClassLoader();\n        InvocationHandler handler = new ProxyInvocationHandler();\n        Class&lt;?&gt;[] interfaces = new Class&lt;?&gt;[]{java.util.Comparator.class};\n        return (Comparator) Proxy.newProxyInstance(classLoader, interfaces, handler);\n    }\n}\n</code></pre> <p>Note: Just like with constant arrays, the following ways to declare and populate an array are equivalent from the point of view of the analysis:</p> <pre><code>Class&lt;?&gt;[] interfaces = new Class&lt;?&gt;[]{java.util.Comparator.class};\n</code></pre> <pre><code>Class&lt;?&gt;[] interfaces = new Class&lt;?&gt;[1];\ninterfaces[0] = Question.class;\n</code></pre> <pre><code>Class&lt;?&gt;[] interfaces = {java.util.Comparator.class};\n</code></pre> <p>The static analysis covers code patterns most frequently used to define dynamic proxy classes. For the exceptional cases where the analysis cannot discover the interface array there is also a manual dynamic proxy configuration mechanism.</p>"},{"location":"#related-documentation_7","title":"Related Documentation","text":"<ul> <li>Configure Dynamic Proxies Manually</li> <li>Reachability Metadata: Dynamic Proxy</li> </ul>"},{"location":"#experimental-agent-options","title":"Experimental Agent Options","text":"<p>The <code>native-image-agent</code> tool has options which are currently experimental and might be enabled in future releases, but can also be changed or removed entirely. These options are described here.</p>"},{"location":"#support-for-predefined-classes","title":"Support For Predefined Classes","text":"<p>Native-image needs all classes to be known at image build time (a \"closed-world assumption\"). However, Java has support for loading new classes at runtime. To emulate class loading, the agent can be told to trace dynamically loaded classes and save their bytecode for later use by the image builder. This functionality can be enabled by adding <code>experimental-class-define-support</code> to the agent option string, e.g.: <code>-agentlib:native-image-agent=config-output-dir=config,experimental-class-define-support</code> Apart from the standard configuration files, the agent will create an <code>agent-extracted-predefined-classes</code> directory in the configuration output directory and write bytecode of newly loaded classes on the go. The configuration directory can then be used by image builder without additional tweaks,. The classes will be loaded during the image build, but will not be initialized or made available to the application. At runtime, if there is an attempt to load a class with the same name and bytecodes as one of the classes encountered during tracing, the predefined class will be supplied to the application.</p>"},{"location":"#known-limitations","title":"Known Limitations","text":"<ul> <li>Native images support \"loading\" a predefined class only once per execution, by just a single class loader.</li> <li>Predefined classes are initialized when they are \"loaded\" at runtime and cannot be initialized at build time.</li> <li>The agent collects all classes which are not loaded by one of the Java VM's built-in class loaders (with some exceptions), that is, from the class path or module path. This includes classes loaded by any custom class loaders.</li> <li>Classes that are generated with varying data in their name or bytecodes, such as sequential or random numbers or timestamps, can generally not be matched to predefined classes at runtime. In these cases, the way such classes are generated needs to be adjusted.</li> </ul>"},{"location":"#printing-configuration-with-origins","title":"Printing Configuration With Origins","text":"<p>For debugging, it may be useful to know the origin of certain configuration entries. By supplying <code>experimental-configuration-with-origins</code> to the agent option string, the agent will output configuration files with configuration entries broken down to the calling context (stack trace) they originate from in tree form. This option should be used in conjunction with <code>config-output-dir=&lt;path&gt;</code> to tell the agent where to output the configuration files. An example agent option string: <code>-agentlib:native-image-agent=config-output-dir=config-with-origins/,experimental-configuration-with-origins</code></p>"},{"location":"#omitting-configuration-from-the-agents-output","title":"Omitting Configuration From The Agent's Output","text":"<p>The agent can omit traced configuration entries present in existing configuration files. There are two ways to specify these existing configuration files:  - By using configuration files from the class path or module path. When <code>experimental-omit-config-from-classpath</code> is added to the agent option string, the class path and module path of the running application are scanned for <code>META-INF/native-image/**/*.json</code> configuration files.  - By explicitly pointing the agent to an existing configuration file directory using <code>config-to-omit=&lt;path&gt;</code>.</p>"},{"location":"#generating-conditional-configuration-using-the-agent","title":"Generating Conditional Configuration Using the Agent","text":"<p>The agent can, using a heuristic, generate configuration with reachability conditions on user specified classes. The agent will track configuration origins and try to deduce the conditions automatically. User classes are specified via an agent filter file (for more information on the format, see more about the agent). Additionally, the resulting configuration can further be filtered using another filter file.</p> <p>Currently, this feature supports two modes:  1. Generating conditional configuration in a single run with the agent.  2. Generating conditional configuration from multiple runs with the agent and finally merging the collected data.</p>"},{"location":"#generating-conditional-configuration-during-an-agent-run","title":"Generating Conditional Configuration During an Agent Run","text":"<p>To enable this mode, add <code>experimental-conditional-config-filter-file=&lt;path&gt;</code> to the agent's command line, where <code>&lt;path&gt;</code> points to an agent filter file. Classes that are considered included by this filter will be designated as user code classes. To further filter the generated configuration, you can use <code>conditional-config-class-filter-file=&lt;path&gt;</code>, where <code>&lt;path&gt;</code> is a path to an agent filter file.</p>"},{"location":"#generating-conditional-configuration-from-multiple-agent-runs","title":"Generating Conditional Configuration From Multiple Agent Runs","text":"<p>Conditional configuration can be generated from multiple agent runs that reach different code paths in the application. Each agent run produces configuration with metadata. <code>native-image-configure</code> is then used to merge the collected data and produce a conditional configuration. To run the agent in this mode, add <code>experimental-conditional-config-part</code> to the agent's command line. Once all the agent runs have finished, you can generate a conditional configuration by invoking:</p> <pre><code>native-image-configure generate-conditional --user-code-filter=&lt;path-to-filter-file&gt; --class-name-filter=&lt;path-to-filter-file&gt; --input-dir=&lt;path-to-agent-run-output-1&gt; --input-dir=&lt;path-to-agent-run-ouput-2&gt; ... --output-dir=&lt;path-to-resulting-conditional-config&gt;\n</code></pre> <p>where:  - <code>--user-code-filter=&lt;path-to-filter-file&gt;</code>: path to an agent filter file that specifies user classes  - (optional) <code>--class-name-filter=&lt;path-to-filter-file&gt;</code>: path to an agent filter file that further filters the generated config</p>"},{"location":"#the-underlying-heuristics","title":"The Underlying Heuristics","text":"<p>Conditions are generated using the call tree of the application. The heuristics work as follows:  1. For each unique method, create a list of all nodes in the call tree that correspond to the method  2. For each unique method, if the method has more than one call node in the tree:   - Find common configuration across all call nodes of that method   - For each call node of the method, propagate configuration that isn't common across these calls to the caller node  3. Repeat 2. until an iteration produced no changes in the call tree.  4. For each node that contains configuration, generate a conditional configuration entry with the method's class as the condition.</p> <p>The primary goal of this heuristic is to attempt to find where a method creates different configuration entries depending on the caller (for example, a method that wraps <code>Class.forName</code> calls.) This implies that the heuristic will not work well for code that generates configuration through a different dependency (for example, same method returns calls <code>Class.forName</code> with different class parameters depending on a system property).</p>"}]}